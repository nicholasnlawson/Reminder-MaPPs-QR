<html>
  <head>
    <title>Medication Chart Generator</title>
    <link
      rel="icon"
      type="image/png"
      href="data:image/jpeg;base64,/9j/4AAQSkZJRgABAQEBLAEsAAD/4QBWRXhpZgAATU0AKgAAAAgABAEaAAUAAAABAAAAPgEbAAUAAAABAAAARgEoAAMAAAABAAIAAAITAAMAAAABAAEAAAAAAAAAAAEsAAAAAQAAASwAAAAB/+0ALFBob3Rvc2hvcCAzLjAAOEJJTQQEAAAAAAAPHAFaAAMbJUccAQAAAgAEAP/hDIFodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvADw/eHBhY2tldCBiZWdpbj0n77u/JyBpZD0nVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkJz8+Cjx4OnhtcG1ldGEgeG1sbnM6eD0nYWRvYmU6bnM6bWV0YS8nIHg6eG1wdGs9J0ltYWdlOjpFeGlmVG9vbCAxMC4xMCc+CjxyZGY6UkRGIHhtbG5zOnJkZj0naHR0cDovL3d3dy53My5vcmcvMTk5OS8wMi8yMi1yZGYtc3ludGF4LW5zIyc+CgogPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9JycKICB4bWxuczp0aWZmPSdodHRwOi8vbnMuYWRvYmUuY29tL3RpZmYvMS4wLyc+CiAgPHRpZmY6UmVzb2x1dGlvblVuaXQ+MjwvdGlmZjpSZXNvbHV0aW9uVW5pdD4KICA8dGlmZjpYUmVzb2x1dGlvbj4zMDAvMTwvdGlmZjpYUmVzb2x1dGlvbj4KICA8dGlmZjpZUmVzb2x1dGlvbj4zMDAvMTwvdGlmZjpZUmVzb2x1dGlvbj4KIDwvcmRmOkRlc2NyaXB0aW9uPgoKIDxyZGY6RGVzY3JpcHRpb24gcmRmOmFib3V0PScnCiAgeG1sbnM6eG1wTU09J2h0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9tbS8nPgogIDx4bXBNTTpEb2N1bWVudElEPmFkb2JlOmRvY2lkOnN0b2NrOjRkNjNhYWZjLWVjOWUtNDMyNy1hYzAzLTAxNmU2YzhjNGI3ZjwveG1wTU06RG9jdW1lbnRJRD4KICA8eG1wTU06SW5zdGFuY2VJRD54bXAuaWlkOmI2ZWU0NzVlLTE5YjYtNGI1ZC05NDU4LTU4NGQ5OWFlMWQ4NDwveG1wTU06SW5zdGFuY2VJRD4KIDwvcmRmOkRlc2NyaXB0aW9uPgo8L3JkZjpSREY+CjwveDp4bXBtZXRhPgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAo8P3hwYWNrZXQgZW5kPSd3Jz8+/9sAQwAFAwQEBAMFBAQEBQUFBgcMCAcHBwcPCwsJDBEPEhIRDxERExYcFxMUGhURERghGBodHR8fHxMXIiQiHiQcHh8e/9sAQwEFBQUHBgcOCAgOHhQRFB4eHh4eHh4eHh4eHh4eHh4eHh4eHh4eHh4eHh4eHh4eHh4eHh4eHh4eHh4eHh4eHh4e/8AAEQgBaAFoAwEiAAIRAQMRAf/EABwAAQEAAgMBAQAAAAAAAAAAAAAIBgcEBQkBA//EAFAQAAEDAgMDBAsKDQIGAwAAAAABAgMEBQYHEQghMRJBUWETFBcyN1ZxdYGRshUYIiRigpKU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"
    />
    <style>
      body {
        font-family: Arial, sans-serif;
        font-size: 18px;
        margin: 0;
        padding: 20px;
        background-color: #f5f5f5;
      }

      h1 {
        color: #004c97;
        text-align: center;
        margin-bottom: 30px;
        font-size: 42px;
        font-weight: bold;
      }

      label {
        display: block;
        margin-bottom: 0px;
        color: #333;
        font-size: 18px;
      }

      textarea {
        width: 65%;
        padding: 10px;
        border: 1px solid #ccc;
        border-radius: 4px;
        resize: vertical;
        font-size: 16px;
        height: 150px;
      }

      /* Toggle switch styles */
      .toggle-switch {
        position: relative;
        display: inline-block;
        width: 40px;
        height: 20px;
      }

      .toggle-switch input {
        opacity: 0;
        width: 0;
        height: 0;
      }

      .toggle-slider {
        position: absolute;
        cursor: pointer;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background-color: #ccc;
        transition: 0.4s;
        border-radius: 20px;
      }

      .toggle-slider:before {
        position: absolute;
        content: "";
        height: 16px;
        width: 16px;
        left: 2px;
        bottom: 2px;
        background-color: white;
        transition: 0.4s;
        border-radius: 50%;
      }

      input:checked + .toggle-slider {
        background-color: #2196f3;
      }

      input:checked + .toggle-slider:before {
        transform: translateX(20px);
      }

      button {
        padding: 10px 20px;
        background-color: #004c97;
        color: white;
        border: none;
        border-radius: 4px;
        cursor: pointer;
        margin-right: 10px;
        font-size: 18px;
        width: 200px;
        height: 60px;
        white-space: normal;
        overflow: visible;
        text-overflow: ellipsis;
      }

      button:hover {
        background-color: #003d7c;
      }

      .button-container {
        margin-bottom: 10px;
        display: flex;
        flex-wrap: wrap;
        align-items: center;
      }

      .button-container button {
        margin-bottom: 10px;
      }

      table {
        width: 100%;
        border-collapse: collapse;
        margin-bottom: 20px;
        font-size: 14px;
        border: 1px solid black;
      }

      th,
      td {
        padding: 10px;
        text-align: left;
        border: 1px solid black;
        font-size: 14px;
      }

      th,
      .patient-info th,
      .signature-table td.label-cell,
      .discharge-comments-header td {
        background-color: #e6e6e6;
        color: #333;
        font-weight: bold;
      }

      .underline {
        text-decoration: underline;
      }

      .patient-info {
        width: 100%;
        border-collapse: collapse;
        margin-bottom: 20px;
      }

      .patient-info td {
        padding: 10px;
        border: 1px solid black;
        font-size: 18px;
      }

      .patient-info .address-row {
        height: 90px;
        vertical-align: top;
      }

      .patient-info .address-space {
        height: 60px;
        margin-top: 5px;
      }

      .selected {
        background-color: #e0e0e0;
      }

      .button-container {
        margin-bottom: 10px;
        display: flex;
        align-items: center;
      }

      .button-container button {
        margin-right: 10px;
      }

      .trigger-phrase {
        font-weight: bold;
      }

      .header-row {
        background-color: #e6e6e6;
      }

      #prescription-container {
        font-family: Arial, sans-serif;
        font-size: 14px;
        margin-top: 20px;
        padding: 0;
        background-color: #fff;
      }

      .prescription-table {
        width: 100%;
        border-collapse: collapse;
        margin-bottom: 20px;
      }

      .prescription-table th,
      .prescription-table td {
        padding: 10px;
        text-align: left;
        border: 1px solid black;
        font-size: 14px;
      }

      .signature-table {
        width: 100%;
        margin-top: 20px;
        border-collapse: collapse;
        table-layout: fixed;
        border: 1px solid black;
        page-break-inside: avoid;
      }

      .signature-table td {
        padding: 10px;
        border: 1px solid black;
        font-size: 14px;
      }

      .signature-table .label-cell {
        background-color: #e6e6e6;
        font-weight: bold;
        width: 30%;
      }

      .signature-table .signature-cell {
        width: 70%;
      }

      #mar-chart-container th.weekend,
      #mar-chart-container td.weekend {
        background-color: #f0f0f0;
        -webkit-print-color-adjust: exact;
        print-color-adjust: exact;
      }

      #mar-chart-container tr.selected th,
      #mar-chart-container tr.selected td {
        background-color: #d0d0d0;
      }

      @media print {
        body * {
          visibility: hidden;
        }
        #prescription-container,
        #chart-container,
        #mar-chart-container,
        #prescription-container *,
        #chart-container *,
        #mar-chart-container * {
          visibility: visible;
        }
        #prescription-container,
        #chart-container,
        #mar-chart-container {
          position: absolute;
          left: 0;
          top: 0;
        }
        .button-container,
        .input-container,
        h1 {
          display: none;
        }

        #chart-container,
        #mar-chart-container {
          overflow-x: visible;
        }

        #chart-container table,
        #mar-chart-container table {
          width: 100%;
          font-size: 10px;
          table-layout: fixed;
          page-break-inside: avoid;
          background-color: #fff;
        }

        #chart-container th,
        #chart-container td,
        #mar-chart-container th,
        #mar-chart-container td {
          padding: 5px;
          font-size: 10px;
          word-wrap: break-word;
          background-color: inherit;
        }

        #chart-container .selected,
        #mar-chart-container .selected {
          background-color: #d6e4ef;
          -webkit-print-color-adjust: exact;
          print-color-adjust: exact;
        }

        #chart-container .section-header,
        #mar-chart-container .section-header {
          page-break-after: avoid;
        }

        #mar-chart-container tr {
          page-break-inside: avoid;
          page-break-after: auto;
        }

        #mar-chart-container thead {
          display: table-header-group;
        }

        #mar-chart-container tfoot {
          display: table-footer-group;
        }

        #mar-chart-table-container {
          page-break-before: always;
        }

        #mar-chart-container th:nth-child(1),
        #mar-chart-container td:nth-child(1) {
          width: 10% !important;
        }

        #mar-chart-container th:nth-child(2),
        #mar-chart-container td:nth-child(2) {
          width: 20% !important;
        }

        #mar-chart-container th:nth-child(n + 3),
        #mar-chart-container td:nth-child(n + 3) {
          width: calc((100% - 30%) / 30) !important;
        }

        #prescription-container {
          font-size: 12px;
        }

        .patient-info td {
          font-size: 16px;
        }

        .patient-info .address-row {
          height: 70px;
        }

        .patient-info .address-space {
          height: 45px;
        }

        .prescription-table th,
        .prescription-table td,
        .signature-table td {
          padding: 5px;
          font-size: 10px;
        }

        th,
        .patient-info th,
        .signature-table td.label-cell,
        #chart-container .header-row,
        #chart-container .patient-info-row,
        #chart-container .discharge-comments-row,
        #mar-chart-container .header-row,
        #mar-chart-container .patient-info-row,
        #chart-container th,
        #mar-chart-container th,
        .prescription-table th,
        .discharge-comments-header td {
          background-color: #e6e6e6 !important;
          -webkit-print-color-adjust: exact !important;
          print-color-adjust: exact !important;
        }

        .prescription-table tr,
        #chart-container tr,
        #mar-chart-container tr {
          page-break-inside: avoid;
        }

        .prescription-table th,
        #chart-container th,
        #mar-chart-container th,
        .header-row,
        .section-header,
        tr.discharge-comments-row th {
          page-break-after: avoid;
        }

        .prescription-table thead,
        #chart-container thead,
        #mar-chart-container thead {
          display: table-header-group;
        }

        .signature-table {
          page-break-inside: avoid !important;
        }

        .discharge-comments-header {
          page-break-after: avoid;
          break-after: avoid;
        }

        .discharge-comments-header + tr {
          page-break-before: avoid;
          break-before: avoid;
        }

        .discharge-comments-content {
          page-break-inside: avoid;
          break-inside: avoid;
        }
      }
      @media print {
        .hospital-logo {
          position: static;
          margin-bottom: 10px;
        }

        #chart-container,
        #mar-chart-container {
          page-break-before: avoid;
        }

        #chart-container table,
        #mar-chart-container table {
          page-break-before: avoid;
          margin-top: 0;
        }

        .logo-container {
          page-break-after: avoid;
        }
      }

      .logo-container {
        margin-bottom: 10px;
      }

      /* QR Code Modal Styles */
      .modal {
        display: none;
        position: fixed;
        z-index: 1000;
        left: 0;
        top: 0;
        width: 100%;
        height: 100%;
        overflow: auto;
        background-color: rgba(0, 0, 0, 0.4);
      }

      .modal-content {
        background-color: #fefefe;
        margin: 5% auto;
        padding: 20px;
        border: 1px solid #888;
        width: 80%;
        max-width: 800px;
        max-height: 80vh;
        overflow-y: auto;
      }

      .close {
        color: #aaa;
        float: right;
        font-size: 28px;
        font-weight: bold;
        cursor: pointer;
      }

      .close:hover,
      .close:focus {
        color: black;
        text-decoration: none;
        cursor: pointer;
      }

      #qr-code-container {
        display: flex;
        flex-wrap: wrap;
        justify-content: center;
        gap: 20px;
        margin-top: 20px;
      }

      .qr-code-item {
        text-align: center;
        width: 200px;
        margin-bottom: 20px;
      }

      .qr-code-image {
        width: 150px;
        height: 150px;
        margin-bottom: 10px;
      }

      .qr-code-info {
        font-size: 14px;
        margin-top: 5px;
      }

      .qr-code-edit-card {
        border: 1px solid #ddd;
        padding: 15px;
        border-radius: 5px;
        width: 300px;
        margin-bottom: 20px;
        background-color: white;
      }

      .medication-header {
        font-size: 16px;
        margin-bottom: 10px;
        padding-bottom: 5px;
        border-bottom: 1px solid #eee;
      }

      .medication-instructions {
        margin-bottom: 15px;
      }

      .medication-instructions textarea {
        padding: 8px;
        border: 1px solid #ccc;
        border-radius: 4px;
        font-size: 14px;
        resize: vertical;
      }

      .medication-preview {
        display: flex;
        justify-content: center;
        margin-top: 10px;
      }

      .qr-print-container {
        width: 100%;
        display: flex;
        justify-content: center;
        margin: 20px 0;
      }

      @media print {
        .qr-code-item {
          page-break-inside: avoid;
          width: 45%;
          margin: 10px;
        }
      }
    </style>
  </head>
  <body>
    <style>
      .warning-banner {
        color: red;
        font-size: 24px;
        font-weight: bold;
        text-align: center;
        margin: 10px 0;
        padding: 10px;
        border: 2px solid red;
        background-color: #ffeeee;
      }
    </style>

    <h1>Medication Chart Generator</h1>

    <div class="input-container">
      <label for="discharge-letter"
        >Paste the medication discharge letter here:</label
      ><br />
      <textarea id="discharge-letter" rows="10" cols="50"></textarea>
    </div>

    <div class="button-container">
      <button onclick="generatePrescription()">Generate Prescription</button>
      <button onclick="generateChart()">Generate Reminder Chart</button>
      <button onclick="generateMARChart()">Generate MAR Chart</button>
      <label for="font-size-slider">Font Size:</label>
      <input
        type="range"
        id="font-size-slider"
        min="12"
        max="36"
        step="2"
        value="16"
        oninput="setFontSize(this.value)"
      />
      <button onclick="deleteSelectedRows()">Delete Selected Rows</button>
      <button onclick="undoDeleteRow()">Undo Deletion</button>
      <button onclick="createBlankRowAfter()">Create Blank Row After</button>
      <button onclick="resetTable()">Reset</button>
      <button onclick="printPrescription()">Print Prescription</button>
      <button onclick="printReminderChart()">Print Reminder Chart</button>
      <button onclick="printMARChart()">Print MAR Chart</button>
      <button onclick="generateQRCodes()">Generate QR Codes</button>
    </div>

    <div id="prescription-container"></div>

    <div id="chart-container"></div>

    <div id="mar-chart-container"></div>

    <div id="qr-code-modal" class="modal">
      <div class="modal-content">
        <span class="close" id="close-qr-code">&times;</span>
        <h2>Medication QR Codes</h2>
        <div class="button-container">
          <button onclick="printQRCodes()" class="btn btn-primary">
            Print QR Codes
          </button>
        </div>
        <div id="qr-code-container"></div>
      </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/qrcode-generator@1.4.4/qrcode.min.js"></script>
    <script>
      const HOSPITAL_LOGO =
        "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAX4AAABaCAYAAAC/kD1oAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyZpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuNi1jMDY3IDc5LjE1Nzc0NywgMjAxNS8wMy8zMC0yMzo0MDo0MiAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENDIDIwMTUgKFdpbmRvd3MpIiB4bXBNTTpJbnN0YW5jZUlEPSJ4bXAuaWlkOjU3RkY5QTVCMkJBQzExRTlCRTgxQzdBOTkyN0QxRkRDIiB4bXBNTTpEb2N1bWVudElEPSJ4bXAuZGlkOjU3RkY5QTVDMkJBQzExRTlCRTgxQzdBOTkyN0QxRkRDIj4gPHhtcE1NOkRlcml2ZWRGcm9tIHN0UmVmOmluc3RhbmNlSUQ9InhtcC5paWQ6NTdGRjlBNTkyQkFDMTFFOUJFODFDN0E5OTI3RDFGREMiIHN0UmVmOmRvY3VtZW50SUQ9InhtcC5kaWQ6NTdGRjlBNUEyQkFDMTFFOUJFODFDN0E5OTI3RDFGREMiLz4gPC9yZGY6RGVzY3JpcHRpb24+IDwvcmRmOlJERj4gPC94OnhtcG1ldGE+IDw/eHBhY2tldCBlbmQ9InIiPz7xY7xxAABD+klEQVR42uxd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"; // Replace ... with your actual Base64 string

      const HOSPITAL_ADDRESS = `South Tyneside and Sunderland NHS Foundation Trust
    South Tyneside District Hospital
    Harton Lane
    South Shields
    NE34 0PL`;

      let deletedRows = [];
      let redoStack = [];
      let originalTableHtml = "";

      const category1Antiepileptics = [
        "carbamazepine",
        "phenytoin",
        "primidone",
        "phenobarbitone",
        "phenobarbital",
        "phenobarbitol",
      ];

      function setFontSize(size) {
        const chartContainer = document.getElementById("chart-container");
        const tableCells = chartContainer.querySelectorAll("td, th");
        const patientInfo = chartContainer.querySelectorAll(".patient-info");
        const patientName = chartContainer.querySelector(".patient-name");

        if (window.matchMedia("print").matches) {
          tableCells.forEach((cell) => {
            cell.style.fontSize = "12px";
          });

          patientInfo.forEach((info) => {
            info.style.fontSize = "14px";
          });

          patientName.style.fontSize = "16px";
        } else {
          const fontSize = parseInt(size);
          tableCells.forEach((cell) => {
            cell.style.fontSize = fontSize + "px";
          });

          patientInfo.forEach((info) => {
            info.style.fontSize = fontSize + 2 + "px";
          });

          patientName.style.fontSize = fontSize + 4 + "px";
        }
      }

      function undoDeleteRow() {
        if (deletedRows.length > 0) {
          const { row, index, parent } = deletedRows.pop();

          // Use the stored parent reference
          if (parent && parent.children) {
            if (index >= parent.children.length) {
              parent.appendChild(row);
            } else {
              parent.insertBefore(row, parent.children[index]);
            }
            redoStack.push({ row, index, parent });
          } else {
            console.error(
              "Cannot restore row - parent element is no longer available"
            );
          }
        }
      }

      function createBlankRowAfter() {
        const selectedReminderRows = document.querySelectorAll(
          "#chart-container tr.selected"
        );
        const selectedMARRows = document.querySelectorAll(
          "#mar-chart-container tr.selected"
        );
        const addedRows = [];

        function processReminderRows(rows) {
          const selectedRows = document.querySelectorAll(
            "#chart-container tr.selected"
          );
          selectedRows.forEach((row) => {
            const newRow = document.createElement("tr");
            const columnCount = row.cells.length;

            if (columnCount === 2) {
              const cell1 = document.createElement("td");
              const cell2 = document.createElement("td");
              cell1.setAttribute("contenteditable", "true");
              cell2.setAttribute("contenteditable", "true");
              cell2.setAttribute("colspan", "5");
              newRow.appendChild(cell1);
              newRow.appendChild(cell2);
            } else {
              for (let i = 0; i < columnCount; i++) {
                const cell = document.createElement("td");
                cell.setAttribute("contenteditable", "true");
                newRow.appendChild(cell);
              }
            }

            row.parentNode.insertBefore(newRow, row.nextSibling);
            row.classList.remove("selected");
            addRowEventListeners(newRow);
          });
        }
        function processMARRows(rows) {
          rows.forEach((selectedRow) => {
            let lastRowOfMedication = selectedRow;
            for (let i = 0; i < 4; i++) {
              const nextRow = lastRowOfMedication.nextElementSibling;
              if (nextRow && !nextRow.querySelector("td[rowspan]")) {
                lastRowOfMedication = nextRow;
              } else {
                break;
              }
            }

            const newMedicationRows = [];
            const timeLabels = [
              "Morning:",
              "Lunchtime:",
              "Mid-Afternoon:",
              "Teatime:",
              "Bedtime:",
            ];

            for (let rowIndex = 0; rowIndex < 5; rowIndex++) {
              const newRow = document.createElement("tr");

              if (rowIndex === 0) {
                const medicationNameCell = document.createElement("td");
                medicationNameCell.setAttribute("contenteditable", "true");
                medicationNameCell.setAttribute("rowspan", "5");
                newRow.appendChild(medicationNameCell);
              }

              const timeLabelCell = document.createElement("td");
              timeLabelCell.setAttribute("contenteditable", "true");
              timeLabelCell.innerHTML = `<strong>${timeLabels[rowIndex]}</strong>`;
              newRow.appendChild(timeLabelCell);

              for (let dayIndex = 0; dayIndex < 30; dayIndex++) {
                const dayCell = document.createElement("td");
                dayCell.setAttribute("contenteditable", "true");
                newRow.appendChild(dayCell);
              }

              newMedicationRows.push(newRow);
            }

            newMedicationRows.forEach((newRow) => {
              lastRowOfMedication.parentNode.insertBefore(
                newRow,
                lastRowOfMedication.nextSibling
              );
              lastRowOfMedication = newRow;
              addRowEventListeners(newRow, "mar");
            });

            selectedRow.classList.remove("selected");

            addedRows.push({
              newRows: newMedicationRows,
              afterRow: lastRowOfMedication,
              chart: "mar",
            });
          });
        }
        processReminderRows(selectedReminderRows);
        processMARRows(selectedMARRows);

        if (addedRows.length > 0) {
          deletedRows.push({ action: "add", rows: addedRows });
          redoStack = [];
        }
      }

      function addTableEventListeners() {
        const tableCells = document.querySelectorAll(
          "#chart-container td, #chart-container th"
        );
        tableCells.forEach((cell) => {
          cell.setAttribute("contenteditable", "true");
        });

        const tableRows = document.querySelectorAll("#chart-container tr");
        tableRows.forEach((row) => addRowEventListeners(row, "reminder"));
      }
      function addRowEventListeners(row, chartType) {
        row.addEventListener("click", () => {
          row.classList.toggle("selected");
        });

        const cells = row.querySelectorAll("td");
        cells.forEach((cell) => {
          cell.setAttribute("contenteditable", "true");
        });
      }
      function addMARTableEventListeners() {
        const tableCells = document.querySelectorAll(
          "#mar-chart-container td, #mar-chart-container th"
        );
        tableCells.forEach((cell) => {
          cell.setAttribute("contenteditable", "true");
        });

        const tableRows = document.querySelectorAll("#mar-chart-container tr");
        tableRows.forEach((row) => addRowEventListeners(row, "mar"));
      }
      function resetTable() {
        const reminderChartContainer =
          document.getElementById("chart-container");
        const marChartContainer = document.getElementById(
          "mar-chart-container"
        );

        reminderChartContainer.innerHTML = originalTableHtml;
        marChartContainer.innerHTML = originalMARTableHtml;

        deletedRows = [];
        redoStack = [];
        addTableEventListeners();
        addMARTableEventListeners();
      }
      let originalMARTableHtml = "";

      function deleteSelectedRows() {
        const selectedReminderRows = Array.from(
          document.querySelectorAll("#chart-container tr.selected")
        );
        const selectedMARRows = Array.from(
          document.querySelectorAll("#mar-chart-container tr.selected")
        );

        selectedReminderRows.forEach((row) => {
          const parent = row.parentNode;
          const index = Array.from(parent.children).indexOf(row);
          deletedRows.push({ row, index, chartType: "reminder", parent });
          row.remove();
        });

        selectedMARRows.forEach((row) => {
          const parent = row.parentNode;
          const index = Array.from(parent.children).indexOf(row);
          deletedRows.push({ row, index, chartType: "mar", parent });
          row.remove();
        });

        redoStack = [];
      }

      const controlledDrugs = [
        "Alfentanil",
        "Amphetamine",
        "Amfetamine",
        "Cocaine",
        "Diamorphine",
        "Dipipanone",
        "Fentanyl",
        "Hydromorphone",
        "Ketamine",
        "Methadone",
        "Methylphenidate",
        "Morphine",
        "Oxycodone",
        "Papaveretum",
        "Pethidine",
        "Remifentanil",
        "Secobarbital",
        "Tapentadol",
        "Buprenorphine",
        "Gabapentin",
        "Meprobamate",
        "Midazolam",
        "Pentazocine",
        "Phenobarbital",
        "Pregabalin",
        "Temazepam",
        "Tramadol",
      ];
      function extractAddress(dischargeLetterText) {
        const medicationsIndex = dischargeLetterText.indexOf(
          "Medications Prescribed on Discharge"
        );
        if (medicationsIndex === -1) {
          return "";
        }

        const relevantText = dischargeLetterText.substring(0, medicationsIndex);
        const addressRegex = /^\s*Address\s*(.+)/im;
        const match = addressRegex.exec(relevantText);
        return match ? match[1].trim() : "";
      }
      function convertToPrescription(dischargeLetterText) {
        const patientName = extractPatientInfo(
          dischargeLetterText,
          "Patient Name"
        );
        const nhsNumber = extractPatientInfo(dischargeLetterText, "NHS Number");
        const medicalRecordNumber = extractPatientInfo(
          dischargeLetterText,
          "Medical Record Number"
        );
        const dateOfBirth = extractPatientInfo(
          dischargeLetterText,
          "Date of Birth"
        );
        const address = extractAddress(dischargeLetterText);

        const lines = dischargeLetterText.split("\n");
        const startIndex = lines.findIndex((line) =>
          line.includes("Medications Prescribed on Discharge")
        );

        if (startIndex === -1) {
          return "Medications section not found in the discharge letter.";
        }

        let prescriptionHtml = `
        <div class="hospital-logo">
      <img src="${HOSPITAL_LOGO}" alt="Hospital Logo">
    </div>
    <h2>Discharge Prescription</h2>
  <table class="patient-info">
    <tr><th colspan="2">Patient Information</th></tr>
    <tr><td><strong>Name:</strong> ${patientName}</td></tr>
    <tr><td><strong>NHS Number:</strong> ${nhsNumber}</td></tr>
    <tr><td><strong>Medical Record Number:</strong> ${medicalRecordNumber}</td></tr>
    <tr><td><strong>Date of Birth:</strong> ${dateOfBirth}</td></tr>
    <tr class="address-row"><td><strong>Address:</strong> ${
      address ? address : '<div class="address-space"></div>'
    }</td></tr>
  </table>
  <h3>Medications Prescribed on Discharge</h3>
  <table class="prescription-table">
    <thead>
      <tr>
        <th>Medication</th>
        <th>Quantity Requested</th>
        <th>Quantity Supplied</th>
      </tr>
    </thead>
    <tbody>
  `;

        let currentEntry = "";
        for (let i = startIndex + 1; i < lines.length; i++) {
          const line = lines[i].trim();
          if (line === "") {
            if (currentEntry !== "") {
              prescriptionHtml += formatPrescriptionEntry(currentEntry);
              currentEntry = "";
            }
          } else if (
            line.toLowerCase().includes("dose changes:") ||
            line
              .toLowerCase()
              .includes("medications started in hospital comment:") ||
            line
              .toLowerCase()
              .includes("medications stopped in hospital comment:") ||
            line.toLowerCase().includes("take home medications comment:") ||
            line.toLowerCase().includes("treatment recommendation (for gp):") ||
            line
              .toLowerCase()
              .includes("information for the community pharmacy:") ||
            line
              .toLowerCase()
              .includes("tto completed by ward pharmacist?: yes") ||
            line.toLowerCase().includes("medications authorised by:")
          ) {
            break;
          } else {
            currentEntry += line + "<br>";
          }
        }

        if (currentEntry !== "") {
          prescriptionHtml += formatPrescriptionEntry(currentEntry);
        }

        prescriptionHtml += `
      </tbody>
    </table>
  `;

        // Add Discharge Medication Comments section
        const additionalInfo = extract_additional_info(dischargeLetterText);
        if (additionalInfo) {
          prescriptionHtml += `
    <table class="prescription-table">
      <tr class="discharge-comments-header">
        <td colspan="3"><strong>Discharge Medication Comments</strong></td>
      </tr>
      <tr class="discharge-comments-content">
        <td colspan="3">${highlightTriggerPhrases(additionalInfo)}</td>
      </tr>
    </table>
    `;
        }
        const category1Antiepileptics = [
          "carbamazepine",
          "phenytoin",
          "primidone",
          "phenobarbitone",
          "phenobarbital",
          "phenobarbitol",
        ];
        prescriptionHtml += `
    <table class="signature-table">
      <tr>
        <td class="label-cell">Prescriber:</td>
        <td class="signature-cell"></td>
      </tr>
      <tr>
        <td class="label-cell">Pharmacist:</td>
        <td class="signature-cell"></td>
      </tr>
      <tr>
        <td class="label-cell">Dispensed by:</td>
        <td class="signature-cell"></td>
      </tr>
      <tr>
        <td class="label-cell">Checked by:</td>
        <td class="signature-cell"></td>
      </tr>
      <tr>
        <td class="label-cell">Date:</td>
        <td class="signature-cell">${getCurrentDate()}</td>
      </tr>
      <tr>
        <td class="label-cell">Hospital Address:</td>
        <td class="signature-cell">${HOSPITAL_ADDRESS.replace(
          /\n/g,
          "<br>"
        )}</td>
      </tr>
    </table>
  `;

        return prescriptionHtml;
      }
      function getCurrentDate() {
        const today = new Date();
        const dd = String(today.getDate()).padStart(2, "0");
        const mm = String(today.getMonth() + 1).padStart(2, "0"); // January is 0!
        const yyyy = today.getFullYear();
        return dd + "/" + mm + "/" + yyyy;
      }

      function formatPrescriptionEntry(entry) {
        const drugInfo = entry.match(/\[(.*?)\]/);
        const isMorphine10mgLiquid =
          drugInfo &&
          /Morphine\s+10\s*MG\/5\s*ML\s*Oral\s*Solution/i.test(drugInfo[1]);

        const isControlledDrug =
          drugInfo &&
          controlledDrugs.some((drug) =>
            drugInfo[1].toLowerCase().includes(drug.toLowerCase())
          ) &&
          !isMorphine10mgLiquid;

        const isCategory1Antiepileptic =
          drugInfo &&
          category1Antiepileptics.some((drug) =>
            drugInfo[1].toLowerCase().includes(drug.toLowerCase())
          );

        let cellContent = entry;
        let additionalContent = "";

        if (isControlledDrug) {
          additionalContent += `
      <br>
      <strong>Total quantity (in words and figures):</strong>
    `;
        }
        if (isCategory1Antiepileptic) {
          additionalContent += `
      <br>
      <strong>***MANUFACTURER SPECIFIC MEDICATION WHEN USED FOR EPILEPSY***</strong>
    `;
        }

        let html = `
    <tr>
      <td>${cellContent}${additionalContent}</td>
      <td></td>
      <td></td>
    </tr>
  `;

        return html;
      }
      function generatePrescription() {
        const dischargeLetterText =
          document.getElementById("discharge-letter").value;
        const prescriptionHtml = convertToPrescription(dischargeLetterText);
        document.getElementById("prescription-container").innerHTML =
          prescriptionHtml;
      }
      function generateChart() {
        const dischargeLetterText =
          document.getElementById("discharge-letter").value;

        const medications =
          parseDischargeLetterMedications(dischargeLetterText);

        // Store medications in window object for QR code generation
        window.medications = medications;

        const patientName = extractPatientInfo(
          dischargeLetterText,
          "Patient Name"
        );
        const nhsNumber = extractPatientInfo(dischargeLetterText, "NHS Number");
        const medicalRecordNumber = extractPatientInfo(
          dischargeLetterText,
          "Medical Record Number"
        );
        const dateOfBirth = extractPatientInfo(
          dischargeLetterText,
          "Date of Birth"
        );

        const liquidMedications = medications.filter(
          (medication) =>
            medication.form === "solution" ||
            medication.form === "syrup" ||
            medication.form === "suspension" ||
            medication.form === "oral solution" ||
            (medication.form === "liquid" &&
              !medication.dosage.toLowerCase().includes("liquid gel")) ||
            medication.form === "elixir" ||
            medication.form === "linctus" ||
            medication.form === "s/f oral soln." ||
            medication.form === "oral soln." ||
            medication.doseUnit === "ml"
        );

        const convertedMedications = liquidMedications.map((medication) => ({
          ...medication,
          minDose:
            medication.doseUnit === "ml"
              ? medication.minDose
              : convertDose(
                  medication.minDose,
                  medication.strength,
                  medication.strengthVolume
                ),
          maxDose:
            medication.doseUnit === "ml"
              ? medication.maxDose
              : convertDose(
                  medication.maxDose,
                  medication.strength,
                  medication.strengthVolume
                ),
          doseUnit: "ml",
        }));

        const chartHtml = generateChartHtml(
          medications,
          convertedMedications,
          patientName,
          nhsNumber,
          medicalRecordNumber,
          dateOfBirth,
          dischargeLetterText
        );
        document.getElementById("chart-container").innerHTML = chartHtml;

        const originalRows = Array.from(
          document.querySelectorAll("#chart-container tr:not(.header-row)")
        ).map((row) => ({
          rowContent: row.outerHTML,
          index: Array.from(row.parentNode.children).indexOf(row),
          chart: "reminder",
        }));
        deletedRows.push({ action: "delete", rows: originalRows });

        originalTableHtml = chartHtml;
        deletedRows = [];
        redoStack = [];
        addTableEventListeners();

        handlePageBreaks();
      }

      function generateMARChart() {
        const dischargeLetterText =
          document.getElementById("discharge-letter").value;
        const medications =
          parseDischargeLetterMedications(dischargeLetterText);

        // Store medications in window object for QR code generation
        window.medications = medications;
        const patientName = extractPatientInfo(
          dischargeLetterText,
          "Patient Name"
        );
        const nhsNumber = extractPatientInfo(dischargeLetterText, "NHS Number");
        const medicalRecordNumber = extractPatientInfo(
          dischargeLetterText,
          "Medical Record Number"
        );
        const dateOfBirth = extractPatientInfo(
          dischargeLetterText,
          "Date of Birth"
        );

        const liquidMedications = medications.filter(
          (medication) =>
            medication.form === "solution" ||
            medication.form === "syrup" ||
            medication.form === "suspension" ||
            medication.form === "oral solution" ||
            (medication.form === "liquid" &&
              !medication.dosage.toLowerCase().includes("liquid gel")) ||
            medication.form === "elixir" ||
            medication.form === "linctus" ||
            medication.form === "s/f oral soln." ||
            medication.form === "oral soln." ||
            medication.doseUnit === "ml"
        );

        const convertedMedications = liquidMedications.map((medication) => ({
          ...medication,
          minDose:
            medication.doseUnit === "ml"
              ? medication.minDose
              : convertDose(
                  medication.minDose,
                  medication.strength,
                  medication.strengthVolume
                ),
          maxDose:
            medication.doseUnit === "ml"
              ? medication.maxDose
              : convertDose(
                  medication.maxDose,
                  medication.strength,
                  medication.strengthVolume
                ),
          doseUnit: "ml",
        }));

        // Store convertedMedications in window object for QR code generation
        window.convertedMedications = convertedMedications;

        const marChartHtml = generateMARChartTable(
          medications,
          patientName,
          nhsNumber,
          medicalRecordNumber,
          dateOfBirth,
          dischargeLetterText
        );
        document.getElementById("mar-chart-container").innerHTML = marChartHtml;
        originalMARTableHtml = marChartHtml;
        addMARTableEventListeners();

        const currentDate = new Date();
        const someDayMedications = medications.filter(
          (medication) =>
            medication.isSomeDays &&
            !medication.isTaper &&
            !medication.isExcludedFromCharts
        );
        const medicationRows = document.querySelectorAll(
          "#mar-chart-container tr:not(.header-row)"
        );
        medicationRows.forEach((row) => {
          const medicationName = row.querySelector("td:first-child").innerText;
          const medication = someDayMedications.find((med) =>
            med.name.includes(medicationName)
          );
          if (medication) {
            const doseTime = getDoseQuantity(
              medication,
              "",
              "",
              convertedMedications,
              true
            );
            crossOutNonAdministrationDays(
              row,
              medication.instructions,
              doseTime,
              currentDate
            );
          }
        });
      }
      function addMARTableEventListeners() {
        const tableCells = document.querySelectorAll(
          "#mar-chart-container td, #mar-chart-container th"
        );
        tableCells.forEach((cell) => {
          cell.setAttribute("contenteditable", "true");
        });

        const tableRows = document.querySelectorAll("#mar-chart-container tr");
        tableRows.forEach((row) => {
          row.addEventListener("click", () => {
            row.classList.toggle("selected");
          });
        });
      }
      function addTableEventListeners() {
        const tableCells = document.querySelectorAll(
          "#chart-container td, #chart-container th"
        );
        tableCells.forEach((cell) => {
          cell.setAttribute("contenteditable", "true");
        });

        const tableRows = document.querySelectorAll("#chart-container tr");
        tableRows.forEach(addRowEventListeners);
      }
      function extractPatientInfo(text, field) {
        const patterns = {
          "Patient Name": /Patient Name:\s*([\w']+),\s*([\w']+)/i,
          "NHS Number": /NHS Number:\s*(\d+(?:\s+\d+)*)/i,
          "Medical Record Number": /Medical Record Number:\s*(.*)/i,
          "Date of Birth": /Date of Birth:\s*(\d{2}\/\d{2}\/(?:\d{4}|\d{2}))/i,
        };

        const regex = patterns[field];
        const match = regex.exec(text);
        if (match) {
          if (field === "Patient Name") {
            const surname = match[1].trim();
            const firstName = match[2].trim();
            return `${surname}, ${firstName}`;
          } else {
            return match[1].trim();
          }
        }
        return "";
      }
      function convertDose(dose, strength, strengthVolume) {
        if (strength && strengthVolume && dose) {
          const doseInMl = (dose / strength) * strengthVolume;
          return doseInMl;
        }
        return dose;
      }

      function parseDischargeLetterMedications(dischargeLetterText) {
        const startTrigger = "Medications Prescribed on Discharge";
        const endTriggers = [
          "Dose Changes:",
          "DOSE CHANGES:",
          "Medications Started in Hospital Comment:",
          "Medications Stopped in Hospital Comment:",
          "Take Home Medications Comment:",
          "Treatment recommendation (For GP):",
          "Information for the Community Pharmacy:",
          "TTO Completed by Ward Pharmacist?:",
          "Medications Authorised by::",
        ];

        // Find the start of the medication section
        const startIndex = dischargeLetterText.indexOf(startTrigger);
        if (startIndex === -1) {
          return []; // No medications found
        }

        // Find the end of the medication section
        let endIndex = dischargeLetterText.length;
        for (const trigger of endTriggers) {
          const triggerIndex = dischargeLetterText.indexOf(trigger, startIndex);
          if (triggerIndex !== -1 && triggerIndex < endIndex) {
            endIndex = triggerIndex;
          }
        }

        // Extract the medication section
        const medicationSection = dischargeLetterText
          .slice(startIndex + startTrigger.length, endIndex)
          .trim();

        // Split the medication section into individual entries
        const medicationEntries = medicationSection.split(/\n\s*\n/);
        const medications = [];

        for (const entry of medicationEntries) {
          let name,
            dosage,
            instructions,
            percentage = "";
          const medicationRegex =
            /^([^\[]+)\s*(?:(\d+(?:\.\d+)?%))?\s*\[(.*?)\],\s+(.*)/;
          const match = medicationRegex.exec(entry);

          if (match) {
            // Logic for medications with square brackets
            name = match[1].trim();
            percentage = match[2] || "";
            dosage = match[3];
            instructions = match[4];
            name =
              name + (percentage ? " " + percentage : "") + " [" + dosage + "]";
          } else {
            // Logic for medications without square brackets
            const parts = entry.split(",");
            if (parts.length >= 2) {
              name = parts[0].trim();
              dosage = name; // Use the full name as dosage for now
              instructions = parts.slice(1).join(",").trim();
            } else {
              // If the entry doesn't match either format, skip it
              continue;
            }
          }

          const strengthRegex =
            /(\d+(?:,\d+)?(?:\.\d+)?)\s*(\w+)?(?:\s*\/\s*(\d+(?:,\d+)?(?:\.\d+)?)\s*(\w+)?)?/i;
          const strengthMatch = strengthRegex.exec(dosage);
          let strength,
            strength1,
            strength2,
            strengthUnit,
            strengthVolume,
            strengthVolumeUnit;

          if (strengthMatch) {
            strength1 = parseFloat(strengthMatch[1].replace(/,/g, ""));
            strengthUnit = (strengthMatch[2] || "").toLowerCase();

            if (strengthMatch[3]) {
              strength2 = parseFloat(strengthMatch[3].replace(/,/g, ""));
              strengthVolumeUnit = strengthMatch[4]
                ? strengthMatch[4].toLowerCase()
                : null;
              if (strengthVolumeUnit === "ml") {
                strength = strength1;
                strengthVolume = strength2;
              } else {
                strength = strength1 + strength2;
                strengthVolume = 1;
              }
            } else {
              strength = strength1;
              strengthVolume = 1;
            }
          } else {
            strength = null;
            strengthUnit = null;
            strengthVolume = 1;
            strengthVolumeUnit = null;
          }

          const doseTabletRegex =
            /(\\d+(?:\\.\\d+)?)\\s*(half\\s+(?:tab|tablet)|quarter\\s+(?:tab|tablet)|tab|tablet)/i;
          const doseTabletMatch = doseTabletRegex.exec(instructions);
          let minDose, maxDose, doseUnit;
          if (doseTabletMatch) {
            const quantity = parseFloat(doseTabletMatch[1]);
            const tabletType = doseTabletMatch[2].toLowerCase();

            if (tabletType.includes("half")) {
              minDose = quantity / 2;
              maxDose = quantity / 2;
              doseUnit = "half tablet";
            } else if (tabletType.includes("quarter")) {
              minDose = quantity / 4;
              maxDose = quantity / 4;
              doseUnit = "quarter tablet";
            } else {
              minDose = quantity;
              maxDose = quantity;
              doseUnit = "tablet";
            }
          }

          const formRegex =
            /(?:tablet|sprays|spray|tabs|caplet|oral\s+solution|oral\s+son\.|capsule|tab|caps|cap|inhalator|patch|capsule\/tablet|inhaler|flexpen|cartridge|sach|sachet|cream|crm|ointment|Scalp Application|sudocrem|lotion|gel|liquid gel|nebule|nebules|nebs|amps|solution|syrup|suspension|oral solution|oral soln\.|liquid|elixir|linctus|s\/f oral soln\.|oral powder|drop|drops|lozenge|gum)/i;
          const formMatch = formRegex.exec(dosage);
          let form = formMatch ? formMatch[0].toLowerCase() : null;

          if (
            form === "device" &&
            (/fluticasone/i.test(dosage) ||
              /glycopyrronium\/formoterol\/budes/i.test(dosage))
          ) {
            form = "inhaler";
          }
          if (form === "sach") {
            form = "sachet";
          } else if (form === "tab") {
            form = "tablet";
          } else if (form === "cap") {
            form = "capsule";
          } else if (form === "oral powder") {
            form = "sachet";
          } else if (form === "drops") {
            form = "drop";
          } else if (form === "scalp application") {
            form = "cream";
          }

          const doseRangeRegex =
            /(\d+(?:,\d+)*(?:\.\d+)?)\s*(?:-\s*(\d+(?:,\d+)*(?:\.\d+)?))?\s*(\w+)?/i;
          const doseRangeMatch = doseRangeRegex.exec(instructions);
          minDose = doseRangeMatch
            ? parseFloat(doseRangeMatch[1].replace(/,/g, ""))
            : null;
          maxDose =
            doseRangeMatch && doseRangeMatch[2] !== undefined
              ? parseFloat(doseRangeMatch[2].replace(/,/g, ""))
              : minDose;
          doseUnit = doseRangeMatch
            ? doseRangeMatch[3]
              ? doseRangeMatch[3].toLowerCase()
              : "units"
            : null;

          if (instructions.toLowerCase().includes("see taper")) {
            minDose = null;
            maxDose = null;
            doseUnit = null;
          }

          if (!minDose || !maxDose) {
            const doseRegex = /(\d+(?:,\d+)*(?:\.\d+)?)\s*(\w+)/i;
            const doseMatch = doseRegex.exec(instructions);
            minDose = doseMatch
              ? parseFloat(doseMatch[1].replace(/,/g, ""))
              : null;
            maxDose = minDose;
            doseUnit = doseMatch ? doseMatch[2].toLowerCase() : null;
          }

          const doseQuantityRegex =
            /(\d+(?:\.\d+)?)\s+(tab|tablet|capsule|cap)/i;
          const doseQuantityMatch = doseQuantityRegex.exec(instructions);
          if (doseQuantityMatch) {
            minDose = parseFloat(doseQuantityMatch[1]);
            maxDose = minDose;
            doseUnit = doseQuantityMatch[2].toLowerCase();
            if (minDose === 0.5) {
              doseUnit = "half " + doseUnit;
              minDose = 1;
              maxDose = 1;
            }
          }

          if (
            minDose &&
            strength &&
            (form === "tablet" ||
              form === "capsule" ||
              form === "tab" ||
              form === "cap") &&
            doseUnit !== "tab" &&
            doseUnit !== "tablet" &&
            doseUnit !== "capsule" &&
            doseUnit !== "cap" &&
            doseUnit !== "half tab" &&
            doseUnit !== "half tablet" &&
            doseUnit !== "half capsule" &&
            doseUnit !== "half cap"
          ) {
            minDose = minDose / strength;
            maxDose = maxDose / strength;
          }

          const sprayCountRegex = /(\d+(?:\.\d+)?)\s*(?:spray|sprays)/i;
          const sprayCountMatch = sprayCountRegex.exec(instructions);
          const sprayCount = sprayCountMatch
            ? parseFloat(sprayCountMatch[1])
            : null;

          let isTaper =
            instructions.toLowerCase().includes("taper") ||
            instructions.toLowerCase().includes("see taper") ||
            entry.toLowerCase().includes("prescriber determined");

          let taperInstructions = null;
          if (isTaper) {
            const taperTableRegex =
              /Dose\s+Frequency\s+Days\s+Hours\s+From\s+Through\s*\n((?:.*\n?)*)/;
            const taperTableMatch = taperTableRegex.exec(entry);

            if (taperTableMatch) {
              taperInstructions = taperTableMatch[1].trim();
            }
          }
          if (name.toLowerCase().includes("scopoderm tts")) {
            const doseMatch = /(\d+(?:\.\d+)?)\s*mg/.exec(instructions);
            if (doseMatch) {
              minDose = maxDose = parseFloat(doseMatch[1]);
            } else {
              minDose = maxDose = 1; // Default to 1mg if no dose specified
            }
            strength = 1; // Each patch is 1mg
            strengthUnit = "mg";
            form = "patch";
          }

          const medicationObj = {
            name: name,
            dosage: dosage,
            instructions: instructions,
            strength: strength,
            strengthVolume: strengthVolume,
            strengthVolumeUnit: strengthVolumeUnit,
            strengthUnit: strengthUnit,
            form: form,
            minDose: minDose,
            maxDose: maxDose,
            doseUnit: doseUnit,
            sprayCount: sprayCount,
            isPrn:
              (instructions.toLowerCase().includes("prn") ||
                instructions.toLowerCase().includes("when required") ||
                instructions.toLowerCase().includes("as required")) &&
              !isTaper, // Only mark as PRN if not a taper
            isTaper: isTaper,
            taperInstructions: taperInstructions,
            isOmitMon: instructions.toLowerCase().includes("omit mon"),
            isSomeDays:
              instructions.toLowerCase().includes("once a week") ||
              instructions.toLowerCase().includes("once week") ||
              instructions.toLowerCase().includes("twice a week") ||
              instructions.toLowerCase().includes("3 x week") ||
              instructions.toLowerCase().includes("6 days of week") ||
              instructions.toLowerCase().includes("every 72 hours") ||
              instructions.toLowerCase().includes("alternate") ||
              instructions.toLowerCase().includes("month") ||
              instructions.toLowerCase().includes("every 3 days") ||
              instructions.toLowerCase().includes("once only one"),
            isExcludedFromCharts: name.includes(
              "Stationery [Steroid Emergency Card]"
            ),
          };

          medications.push(medicationObj);
        }

        return medications;
      }
      function addTriggerPhrases(medication) {
        let additionalInfo = "";

        if (
          medication.instructions.toLowerCase().includes("unlicensed-nebulised")
        ) {
          additionalInfo +=
            "<br><strong>***TO BE USED IN THE NEBULISER***</strong>";
        } else if (
          (medication.name.toLowerCase().includes("colistin") ||
            medication.name.toLowerCase().includes("colistimethate")) &&
          medication.instructions.toLowerCase().includes("nebulised")
        ) {
          additionalInfo +=
            "<br><strong>***TO BE USED IN THE NEBULISER***</strong>";
        } else if (
          medication.dosage.toLowerCase().includes("ultibro") &&
          medication.dosage.toLowerCase().includes("breezhaler") &&
          medication.dosage.toLowerCase().includes("cap+device")
        ) {
          additionalInfo +=
            "<br><strong>***CAPSULE TO BE INHALED VIA BREEZHALER***</strong>";
        } else if (
          medication.dosage.toLowerCase().includes("tiotropium") &&
          medication.dosage.toLowerCase().includes("handihaler") &&
          medication.dosage.toLowerCase().includes("capsules")
        ) {
          additionalInfo +=
            "<br><strong>***CAPSULE TO BE INHALED VIA HANDIHALER***</strong>";
        }

        if (
          category1Antiepileptics.some((med) =>
            medication.name.toLowerCase().includes(med)
          )
        ) {
          additionalInfo +=
            "<br><strong>***MANUFACTURER SPECIFIC MEDICATION WHEN USED FOR EPILEPSY***</strong>";
        }

        return additionalInfo;
      }
      function generateChartHtml(
        medications,
        convertedMedications,
        patientName,
        nhsNumber,
        medicalRecordNumber,
        dateOfBirth,
        dischargeLetterText
      ) {
        let html = `
    <div class="chart-container">
    <div class="hospital-logo">
        <img src="${HOSPITAL_LOGO}" alt="Hospital Logo">
      <h2>Discharge Medication Chart</h2>
      <table class="patient-info">
        <tr><th>Patient Information</th></tr>
        <tr><td><strong>Name:</strong> ${patientName}</td></tr>
        <tr><td><strong>NHS Number:</strong> ${nhsNumber}</td></tr>
        <tr><td><strong>Medical Record Number:</strong> ${medicalRecordNumber}</td></tr>
        <tr><td><strong>Date of Birth:</strong> ${dateOfBirth}</td></tr>
      </table>
      <table class="medication-table">
        <tr class="header-row">
          <th style="width: 30%;">Medication</th>
          <th style="width: 14%;">Morning</th>
          <th style="width: 14%;">Lunchtime</th>
          <th style="width: 14%;">Mid-Afternoon</th>
          <th style="width: 14%;">Teatime</th>
          <th style="width: 14%;">Bedtime</th>
        </tr>
  `;

        const dailyMedications = medications.filter(
          (medication) =>
            !medication.isPrn &&
            !medication.isTaper &&
            !medication.isSomeDays &&
            !medication.isExcludedFromCharts
        );
        if (dailyMedications.length > 0) {
          html +=
            '<tr class="header-row"><td colspan="6"><strong>Medication to be Taken <span class="underline">EVERY DAY</span></strong></td></tr>';
          dailyMedications.forEach((medication) => {
            html += "<tr>";
            html += `<td>${medication.dosage}`;
            html += addTriggerPhrases(medication);
            html += "</td>";
            html += `<td>${getDoseQuantity(
              medication,
              "06:00",
              "10:59",
              convertedMedications
            )}</td>`;
            html += `<td>${getDoseQuantity(
              medication,
              "11:00",
              "13:59",
              convertedMedications
            )}</td>`;
            html += `<td>${getDoseQuantity(
              medication,
              "14:00",
              "16:59",
              convertedMedications
            )}</td>`;
            html += `<td>${getDoseQuantity(
              medication,
              "17:00",
              "19:59",
              convertedMedications
            )}</td>`;
            html += `<td>${getDoseQuantity(
              medication,
              "20:00",
              "23:59",
              convertedMedications
            )}</td>`;
            html += "</tr>";
          });
        }

        const someDayMedications = medications.filter(
          (medication) => medication.isSomeDays && !medication.isTaper
        );
        if (someDayMedications.length > 0) {
          html +=
            '<tr class="header-row"><td colspan="6"><strong>Medications to be Taken on <span class="underline">SOME</span> Days</strong></td></tr>';
          someDayMedications.forEach((medication) => {
            html += "<tr>";
            html += `<td>${medication.dosage}`;
            html += addTriggerPhrases(medication);
            html += "</td>";
            html += '<td colspan="5">';
            html += getDoseQuantity(
              medication,
              "",
              "",
              convertedMedications,
              true
            );
            html += " ";
            html += formatInstructions(medication.instructions);
            html += "</td>";
            html += "</tr>";
          });
        }

        const prnMedications = medications.filter(
          (medication) => medication.isPrn && !medication.isExcludedFromCharts
        );
        if (prnMedications.length > 0) {
          html +=
            '<tr class="header-row"><td colspan="6"><strong>Medications to be Taken <span class="underline">AS REQUIRED</span></strong></td></tr>';
          prnMedications.forEach((medication) => {
            html += "<tr>";
            html += `<td>${medication.dosage}`;
            html += addTriggerPhrases(medication);
            html += "</td>";
            html += '<td colspan="5">';
            html += getDoseQuantity(
              medication,
              "",
              "",
              convertedMedications,
              true
            );
            html += " ";
            html += formatInstructions(medication.instructions);
            html += "</td>";
            html += "</tr>";
          });
        }

        const taperMedications = medications.filter(
          (medication) => medication.isTaper && !medication.isExcludedFromCharts
        );
        if (taperMedications.length > 0) {
          html +=
            '<tr class="header-row"><td colspan="6"><strong>Medication with Tapering Dose</strong></td></tr>';
          taperMedications.forEach((medication) => {
            html += "<tr>";
            html += `<td>${medication.dosage}`;
            html += addTriggerPhrases(medication);
            html += "</td>";
            html += '<td colspan="5">';
            if (medication.taperInstructions) {
              let formattedInstructions;

              // First, identify specific known types that need special handling
              if (
                medication.form === "cream" ||
                medication.form === "ointment" ||
                medication.form === "scalp application" ||
                medication.form === "gel" ||
                medication.form === "lotion"
              ) {
                // Use cream-specific formatter
                formattedInstructions = formatCreamTaperInstructions(
                  medication.taperInstructions
                );
              } else if (
                medication.form === "solution" ||
                medication.form === "syrup" ||
                medication.form === "suspension" ||
                medication.form === "oral solution" ||
                (medication.form === "liquid" &&
                  !medication.dosage.toLowerCase().includes("liquid gel")) ||
                medication.form === "elixir" ||
                medication.form === "linctus" ||
                medication.form === "s/f oral soln." ||
                medication.form === "oral soln." ||
                medication.doseUnit === "ml"
              ) {
                // Use liquid-specific formatter
                formattedInstructions = formatLiquidTaperInstructions(
                  medication.taperInstructions,
                  medication,
                  convertedMedications
                );
              } else if (
                medication.form === "tablet" ||
                medication.form === "capsule" ||
                medication.form === "tab" ||
                medication.form === "cap"
              ) {
                // Use tablet/capsule formatter
                formattedInstructions = formatTaperInstructions(
                  medication.taperInstructions,
                  medication.dosage
                );
              } else {
                // For ALL other formulations, use the generic miscellaneous formatter
                formattedInstructions = formatMiscellaneousTaperInstructions(
                  medication.taperInstructions,
                  medication
                );
              }

              html += `<strong>Taper Instructions:</strong><br>${formattedInstructions}`;
            } else {
              html += "&check; See taper instructions";
            }
            html += "</td>";
            html += "</tr>";
          });
        }

        const additional_info = extract_additional_info(dischargeLetterText);
        if (additional_info) {
          html += `<tr class="discharge-comments-row"><th colspan="6">Discharge Medication Comments</th></tr>`;
          html += `<tr><td colspan="6">${highlightTriggerPhrases(
            additional_info
          )}</td></tr>`;
        }

        html += "</table>"; // Close the main table

        // Add a new table for the signature row
        html += `
<table class="signature-table">
  <tr>
    <td class="label-cell">Chart prepared by:</td>
    <td class="signature-cell"></td>
  </tr>
  <tr>
    <td class="label-cell">Chart checked by:</td>
    <td class="signature-cell"></td>
  </tr>
</table>
`;
        return html;
      }

      function generateMARChartTable(
        medications,
        patientName,
        nhsNumber,
        medicalRecordNumber,
        dateOfBirth,
        dischargeLetterText
      ) {
        const currentDate = new Date();
        const formattedDate = `${currentDate.getDate()}/${
          currentDate.getMonth() + 1
        }/${currentDate.getFullYear().toString().slice(-2)}`;

        const getPatientDemographicsHTML = () => {
          return `
      <tr>
        <th colspan="2" contenteditable="true">Medication Administration Record (MAR)</th>
        <th colspan="30"></th>
      </tr>
      <tr>
        <th colspan="2">
          <span class="patient-info" contenteditable="true">Name: ${patientName}</span><br>
          <span class="patient-info" contenteditable="true">NHS Number: ${nhsNumber}</span><br>
          <span class="patient-info" contenteditable="true">Medical Record Number: ${medicalRecordNumber}</span><br>
          <span class="patient-info" contenteditable="true">Date of Birth: ${dateOfBirth}</span>
        </th>
        <th colspan="30"></th>
      </tr>
    `;
        };

        let tableHTML = `
    <div id="mar-chart-table-container">
      <div class="logo-container">
        <div class="hospital-logo">
          <img src="${HOSPITAL_LOGO}" alt="Hospital Logo">
        </div>
    
      <table>
        <thead>
          ${getPatientDemographicsHTML()}
          <tr>
            <th>Medication</th>
            <th>Dose</th>
            ${getMonthCalendarHeader(currentDate)}
          </tr>
        </thead>
        <tbody>
  `;

        const liquidMedications = medications.filter(
          (medication) =>
            medication.form === "solution" ||
            medication.form === "syrup" ||
            medication.form === "suspension" ||
            medication.form === "oral solution" ||
            (medication.form === "liquid" &&
              !medication.dosage.toLowerCase().includes("liquid gel")) ||
            medication.form === "elixir" ||
            medication.form === "linctus" ||
            medication.form === "s/f oral soln." ||
            medication.form === "oral soln." ||
            medication.doseUnit === "ml"
        );

        const convertedMedications = liquidMedications.map((medication) => ({
          ...medication,
          minDose:
            medication.doseUnit === "ml"
              ? medication.minDose
              : convertDose(
                  medication.minDose,
                  medication.strength,
                  medication.strengthVolume
                ),
          maxDose:
            medication.doseUnit === "ml"
              ? medication.maxDose
              : convertDose(
                  medication.maxDose,
                  medication.strength,
                  medication.strengthVolume
                ),
          doseUnit: "ml",
        }));

        const taperMedications = medications.filter(
          (medication) => medication.isTaper && !medication.isExcludedFromCharts
        );

        function getDoseTimingForSpecialInstruction(
          instructions,
          administrationTimes
        ) {
          if (
            instructions.toLowerCase().includes("6 days of week am (omit XXX)")
          ) {
            return administrationTimes.map((time) => {
              if (time.label === "Morning") {
                return { ...time, start: "08:00", end: "08:00" };
              }
              return time;
            });
          }
          return administrationTimes;
        }

        const renderMedicationSection = (
          medications,
          sectionTitle,
          isTaperSection = false,
          startNewPage = false
        ) => {
          if (medications.length === 0) return "";

          let sectionHTML = "";

          if (startNewPage) {
            sectionHTML += "</tbody></table>";
            sectionHTML += '<div style="page-break-before: always;"></div>';
            sectionHTML += "<table><thead>";
            sectionHTML += getPatientDemographicsHTML();
            sectionHTML += "<tr><th>Medication</th><th>Dose</th>";
            sectionHTML += getMonthCalendarHeader(currentDate);
            sectionHTML += "</tr></thead><tbody>";
          }

          sectionHTML += `
    <tr class="header-row">
      <td colspan="32" contenteditable="true">${sectionTitle}</td>
    </tr>
  `;

          medications.forEach((medication) => {
            const administrationTimes = [
              { label: "Morning", start: "06:00", end: "10:59" },
              { label: "Lunchtime", start: "11:00", end: "13:59" },
              { label: "Mid-Afternoon", start: "14:00", end: "16:59" },
              { label: "Teatime", start: "17:00", end: "19:59" },
              { label: "Bedtime", start: "20:00", end: "23:59" },
            ];

            const frequencyInstructions = formatInstructions(
              medication.instructions
            );
            const specialInstructionTimes = getDoseTimingForSpecialInstruction(
              medication.instructions,
              administrationTimes
            );

            const medicationInfo = medication.name.includes("[")
              ? medication.name.match(/\[(.*?)\]/)[1]
              : medication.dosage;

            if (medication.isTaper) {
              let formattedInstructions = "";

              if (medication.taperInstructions) {
                // First, identify specific known types that need special handling
                if (
                  medication.form === "cream" ||
                  medication.form === "ointment" ||
                  medication.form === "scalp application" ||
                  medication.form === "gel" ||
                  medication.form === "lotion"
                ) {
                  // Use cream-specific formatter
                  formattedInstructions = formatCreamTaperInstructions(
                    medication.taperInstructions
                  );
                } else if (
                  medication.form === "solution" ||
                  medication.form === "syrup" ||
                  medication.form === "suspension" ||
                  medication.form === "oral solution" ||
                  (medication.form === "liquid" &&
                    !medication.dosage.toLowerCase().includes("liquid gel")) ||
                  medication.form === "elixir" ||
                  medication.form === "linctus" ||
                  medication.form === "s/f oral soln." ||
                  medication.form === "oral soln." ||
                  medication.doseUnit === "ml"
                ) {
                  // Use liquid-specific formatter
                  formattedInstructions = formatLiquidTaperInstructions(
                    medication.taperInstructions,
                    medication,
                    convertedMedications
                  );
                } else if (
                  medication.form === "tablet" ||
                  medication.form === "capsule" ||
                  medication.form === "tab" ||
                  medication.form === "cap"
                ) {
                  // Use tablet/capsule formatter
                  formattedInstructions = formatTaperInstructions(
                    medication.taperInstructions,
                    medication.dosage
                  );
                } else {
                  // For ALL other formulations, use the generic miscellaneous formatter
                  formattedInstructions = formatMiscellaneousTaperInstructions(
                    medication.taperInstructions,
                    medication
                  );
                }

                administrationTimes.forEach((time, index) => {
                  const { isTaperTimeRange, frequency } = checkTaperTimeRange(
                    medication.taperInstructions,
                    time.start,
                    time.end
                  );

                  sectionHTML += `
            <tr>
              ${
                index === 0
                  ? `<td rowspan="${
                      administrationTimes.length
                    }"><strong>${medicationInfo}</strong><br>${formattedInstructions}${addTriggerPhrases(
                      medication
                    )}</td>`
                  : ""
              }
              <td><strong>${time.label}</strong>: ${
                    isTaperTimeRange ? "&check; See Taper Instructions" : ""
                  }</td>
              ${getMonthCalendarCells(currentDate, isTaperTimeRange)}
            </tr>
          `;
                });
              } else {
                administrationTimes.forEach((time, index) => {
                  const { isTaperTimeRange, frequency } = checkTaperTimeRange(
                    medication.taperInstructions,
                    time.start,
                    time.end
                  );

                  sectionHTML += `
            <tr>
              ${
                index === 0
                  ? `<td rowspan="${
                      administrationTimes.length
                    }" contenteditable="true"><strong>${medicationInfo}</strong>${addTriggerPhrases(
                      medication
                    )}</td>`
                  : ""
              }
              <td contenteditable="true"><strong>${time.label}</strong>: ${
                    isTaperTimeRange ? "&check; See Taper Instructions" : ""
                  }</td>
              ${getMonthCalendarCells(currentDate, isTaperTimeRange)}
            </tr>
          `;
                });
              }
            } else if (medication.isPrn) {
              const prnDose = getDoseQuantity(
                medication,
                "",
                "",
                convertedMedications,
                true
              );
              const formattedPrnDose = formatDoseQuantity(medication, prnDose);

              specialInstructionTimes.forEach((time, index) => {
                sectionHTML += `
          <tr>
            ${
              index === 0
                ? `<td rowspan="${
                    specialInstructionTimes.length
                  }"><strong>${medicationInfo}</strong><br>${formattedPrnDose} ${frequencyInstructions}${addTriggerPhrases(
                    medication
                  )}</td>`
                : ""
            }
            <td><strong>${time.label}</strong></td>
            ${getMonthCalendarCells(currentDate, "")}
          </tr>
        `;
              });
            } else {
              const regularDose = getDoseQuantity(
                medication,
                "",
                "",
                convertedMedications,
                false
              );
              const formattedRegularDose = formatDoseQuantity(
                medication,
                regularDose
              );

              specialInstructionTimes.forEach((time, index) => {
                let dose = getDoseQuantity(
                  medication,
                  time.start,
                  time.end,
                  convertedMedications
                );
                const formattedDose = formatDoseQuantity(medication, dose);

                sectionHTML += `
          <tr>
            ${
              index === 0
                ? `<td rowspan="${
                    specialInstructionTimes.length
                  }"><strong>${medicationInfo}</strong><br>${formattedRegularDose} ${frequencyInstructions}${addTriggerPhrases(
                    medication
                  )}</td>`
                : ""
            }
            <td><strong>${time.label}</strong>: ${dose ? dose : ""}</td>
            ${getMonthCalendarCells(currentDate)}
          </tr>
        `;
              });
            }
          });

          return sectionHTML;
        };

        const dailyMedications = medications.filter(
          (medication) =>
            !medication.isPrn &&
            !medication.isTaper &&
            !medication.isSomeDays &&
            !medication.isExcludedFromCharts
        );
        tableHTML += renderMedicationSection(
          dailyMedications,
          '<strong>Medications to be Taken <span class="underline">EVERY DAY</span>'
        );

        const someDayMedications = medications.filter(
          (medication) =>
            medication.isSomeDays &&
            !medication.isTaper &&
            !medication.isExcludedFromCharts
        );
        tableHTML += renderMedicationSection(
          someDayMedications,
          '<strong>Medications to be Taken on <span class="underline">SOME</span> Days',
          false,
          true
        );

        const prnMedications = medications.filter(
          (medication) => medication.isPrn && !medication.isExcludedFromCharts
        );
        tableHTML += renderMedicationSection(
          prnMedications,
          '<strong>Medications to be Taken <span class="underline">AS REQUIRED</span>',
          false,
          true
        );

        if (taperMedications.length > 0) {
          tableHTML += renderMedicationSection(
            taperMedications,
            "<strong>Medications with Tapering Dose",
            true,
            true
          );
        }

        // Add additional information section
        const additionalInfo = extract_additional_info(dischargeLetterText);
        if (additionalInfo) {
          tableHTML += `
    <tr class="discharge-comments-header">
      <td colspan="32" contenteditable="true"><strong>Discharge Medication Comments</strong></td>
    </tr>
    <tr class="discharge-comments-content">
      <td colspan="32" contenteditable="true">${highlightTriggerPhrases(
        additionalInfo
      )}</td>
    </tr>
  `;
        }

        tableHTML += `
      </tbody>
    </table>
    </div>
  `;
        tableHTML += `
<table class="signature-table">
  <tr>
    <td class="label-cell">Chart prepared by:</td>
    <td class="signature-cell"></td>
  </tr>
  <tr>
    <td class="label-cell">Chart checked by:</td>
    <td class="signature-cell"></td>
  </tr>
</table>
`;

        return tableHTML;
      }

      function formatTaperInstructions(taperInstructions, dosage) {}

      function formatLiquidTaperInstructions(
        taperInstructions,
        medication,
        convertedMedications
      ) {}
      function formatDoseQuantity(medication, dose) {
        if (!dose) return "";

        const formattedDose = dose.replace("&check;", "").trim();
        const parkinsonsmedications = [
          "levodopa",
          "co careldopa",
          "co-beneldopa",
          "entacapone",
          "opicapone",
          "tolcapone",
          "cabergoline",
          "rotigotine",
          "ropinirole",
          "rasagiline",
          "selegiline",
          "pramipexole",
          "bromocriptine",
          "apomorphine",
          "amantadine",
        ];

        if (
          parkinsonsmedications.some((med) =>
            medication.name.toLowerCase().includes(med)
          )
        ) {
          return formattedDose.replace(/\(\d+(?:am|pm)\)/i, "").trim();
        }

        return formattedDose;
      }

      function formatInstructions(instructions) {
        const routeRegex =
          /\b(ORAL|INHALATION|EAR-LEFT|EAR-RIGHT|EARS-BOTH|LEFT EAR|RIGHT EAR|BOTH EARS|BOTH EYES|LEFT EYE|RIGHT EYE|SUBLINGUAL|INHALE WITH OXYGEN|INHALE WITH AIR|INTRAMUSCULAR|INTRAVENOUS-SLOW INJECTION|UNLICENSED-NEBULISED|NEBULISED|BUCCAL|RECTAL|TOPICAL|NO ROUTE|NOSTRIL-LEFT|NOSTRIL-BOTH|NOSTRIL_RIGHT|NASAL|INTRANASAL|VAGINAL|VAGINALLY|INJECTION|VIA PEG TUBE|SUBCUTANEOUS|UNLICENSED-SUBCUT INFUSION|NASOGASTRIC|NASOJEJUNAL|UNLICENSED-TUBE|UNLICENSED-NG|NASOJEJUNAL|NG|NJ|TOPICALLY|AEROGENAIR|AEROGENOXY|AEROGENAIR|AEROGENOXY)\b/i;
        const routeMatch = routeRegex.exec(instructions);
        const instructionsAfterRoute = routeMatch
          ? instructions
              .substring(routeMatch.index + routeMatch[0].length)
              .trim()
          : "";

        return instructionsAfterRoute;
      }

      function getDayOfWeek(year, month, day) {
        const daysOfWeek = ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"];
        const date = new Date(year, month, day);
        return daysOfWeek[date.getDay()];
      }

      function getMonthCalendarHeader(startDate) {
        const daysInMonth = 30;
        let headerHTML = "";

        for (let day = 0; day < daysInMonth; day++) {
          const currentDate = new Date(startDate);
          currentDate.setDate(startDate.getDate() + day);
          const formattedDate = `${currentDate.getDate()}/${
            currentDate.getMonth() + 1
          }`;
          const dayOfWeek = getDayOfWeek(
            currentDate.getFullYear(),
            currentDate.getMonth(),
            currentDate.getDate()
          );
          const isWeekend = dayOfWeek === "Sun" || dayOfWeek === "Sat";
          const headerClass = isWeekend ? "weekend" : "";
          headerHTML += `<th class="${headerClass}">${formattedDate}</th>`;
        }

        return headerHTML;
      }

      function getMonthCalendarCells(startDate) {
        const daysInMonth = 30;
        let cellsHTML = "";

        for (let day = 0; day < daysInMonth; day++) {
          const currentDate = new Date(startDate);
          currentDate.setDate(startDate.getDate() + day);
          const dayOfWeek = getDayOfWeek(
            currentDate.getFullYear(),
            currentDate.getMonth(),
            currentDate.getDate()
          );
          const isWeekend = dayOfWeek === "Sun" || dayOfWeek === "Sat";
          const cellClass = isWeekend ? "weekend" : "";
          cellsHTML += `<td class="${cellClass}"></td>`;
        }

        return cellsHTML;
      }
      function crossOutNonAdministrationDays(
        row,
        instructions,
        doseTime,
        currentDate
      ) {
        const cells = row.querySelectorAll(
          "td:not(:first-child):not(:last-child)"
        );
        const daysOfWeek = [
          "sunday",
          "monday",
          "tuesday",
          "wednesday",
          "thursday",
          "friday",
          "saturday",
        ];
        const instructionsLowerCase = instructions.toLowerCase();
        const doseDays = getDaysOfWeek(instructionsLowerCase);
        const isOnceAWeek = instructionsLowerCase.includes("once a week");
        const isTwiceAWeek = instructionsLowerCase.includes("twice a week");
        const isEveryThreeDays = instructionsLowerCase.includes("every 3 days");
        const isEvery72Hours = instructionsLowerCase.includes("every 72 hours");
        const isAlternateDay = instructionsLowerCase.includes("alternate");

        cells.forEach((cell, index) => {
          const cellDate = new Date(currentDate);
          cellDate.setDate(cellDate.getDate() + index);
          const dayOfWeek = daysOfWeek[cellDate.getDay()];

          if (isOnceAWeek) {
            const doseDayIndex = doseDays.findIndex((day) =>
              day.startsWith(dayOfWeek)
            );
            const onceAWeekDoseTimeRegex =
              /\(once a week (?:.*?)\) (\d{1,2}(?:am|pm))/i;
            const onceAWeekDoseTimeMatch =
              onceAWeekDoseTimeRegex.exec(instructions);
            const doseTimeFromInstructions = onceAWeekDoseTimeMatch
              ? onceAWeekDoseTimeMatch[1]
              : null;

            if (
              doseDayIndex === -1 ||
              (doseTimeFromInstructions &&
                !checkTimeRange(instructions, "", "", doseTimeFromInstructions))
            ) {
              cell.innerHTML =
                '<span style="text-decoration: line-through;">&nbsp;</span>';
            }
          } else if (isTwiceAWeek) {
            const doseDayIndexes = doseDays.reduce((indexes, day, i) => {
              if (day.startsWith(dayOfWeek)) {
                indexes.push(i);
              }
              return indexes;
            }, []);
            if (
              doseDayIndexes.length < 2 ||
              (doseTime && !checkTimeRange(instructions, "", "", doseTime))
            ) {
              cell.innerHTML =
                '<span style="text-decoration: line-through;">&nbsp;</span>';
            }
          } else if (isEveryThreeDays || isEvery72Hours) {
            if (
              index % 3 !== 0 ||
              (doseTime && !checkTimeRange(instructions, "", "", doseTime))
            ) {
              cell.innerHTML =
                '<span style="text-decoration: line-through;">&nbsp;</span>';
            }
          } else if (isAlternateDay) {
            if (
              index % 2 !== 0 ||
              (doseTime && !checkTimeRange(instructions, "", "", doseTime))
            ) {
              cell.innerHTML =
                '<span style="text-decoration: line-through;">&nbsp;</span>';
            }
          } else if (doseDays.length > 0) {
            if (
              !doseDays.some((day) => day.startsWith(dayOfWeek)) ||
              (doseTime && !checkTimeRange(instructions, "", "", doseTime))
            ) {
              cell.innerHTML =
                '<span style="text-decoration: line-through;">&nbsp;</span>';
            }
          }
        });
      }

      function getDaysOfWeek(instructions) {
        const dayRegex =
          /\b(mon|tue|wed|thu|fri|sat|sun|monday|tuesday|wednesday|thursday|friday|saturday|sunday)\b/gi;
        return instructions.match(dayRegex) || [];
      }
      function getDaysOfWeek(instructions) {
        const daysOfWeek = [
          "sunday",
          "monday",
          "tuesday",
          "wednesday",
          "thursday",
          "friday",
          "saturday",
        ];
        const foundDays = [];

        for (const day of daysOfWeek) {
          if (instructions.toLowerCase().includes(day)) {
            foundDays.push(day);
          }
        }

        return foundDays;
      }

      function highlightTriggerPhrases(text) {
        const triggerPhrases = [
          /Dose Changes:/g,
          /DOSE CHANGES:/g,
          /Medications Started in Hospital Comment:/g,
          /Medications Stopped in Hospital Comment:/g,
          /Take Home Medications Comment:/g,
          /Treatment recommendation \(For GP\):/g,
          /Information for the Community Pharmacy:/g,
          /TTO Completed by Ward Pharmacist\?:/g,
          /Medications Authorised by::/g,
        ];

        triggerPhrases.forEach((phrase) => {
          text = text.replace(
            phrase,
            `<strong class="trigger-phrase">$&</strong>`
          );
        });

        return text.replace(/\n/g, "<br>");
      }

      function formatInstructions(instructions) {
        const routeRegex =
          /\b(ORAL|INHALATION|EAR-LEFT|EAR-RIGHT|EARS-BOTH|LEFT EAR|RIGHT EAR|BOTH EARS|BOTH EYES|LEFT EYE|RIGHT EYE|SUBLINGUAL|INHALE WITH OXYGEN|INHALE WITH AIR|INTRAMUSCULAR|INTRAVENOUS-SLOW INJECTION|UNLICENSED-NEBULISED|NEBULISED|BUCCAL|RECTAL|TOPICAL|NO ROUTE|NOSTRIL-LEFT|NOSTRIL-BOTH|NOSTRIL_RIGHT|NASAL|INTRANASAL|VAGINAL|VAGINALLY|INJECTION|VIA PEG TUBE|SUBCUTANEOUS|UNLICENSED-SUBCUT INFUSION|NASOGASTRIC|NASOJEJUNAL|UNLICENSED-TUBE|UNLICENSED-NG|NASOJEJUNAL|NG|NJ|TOPICALLY|AEROGENAIR|AEROGENOXY)\b/i;

        const routeMatch = routeRegex.exec(instructions);
        let instructionsAfterRoute = routeMatch
          ? instructions
              .substring(routeMatch.index + routeMatch[0].length)
              .trim()
          : instructions;

        // Function to properly capitalize day names
        function capitalizeDayName(day) {
          const dayMap = {
            mon: "Monday",
            tues: "Tuesday",
            wed: "Wednesday",
            thurs: "Thursday",
            fri: "Friday",
            frid: "Friday",
            sat: "Saturday",
            sun: "Sunday",
          };
          return dayMap[day.toLowerCase()] || day;
        }

        // Check if instructions after route contain ONLY times in HHMM format
        const timePattern = /\b(\d{4})(?:,\s*(\d{4}))*/g;
        const cleanedInstructions = instructionsAfterRoute
          .replace(/\s+/g, " ")
          .trim();
        const containsOnlyTimes = cleanedInstructions
          .split(",")
          .every((part) => /^\s*\d{4}\s*$/.test(part.trim()));

        if (containsOnlyTimes && timePattern.test(cleanedInstructions)) {
          const times = [];
          let match;
          timePattern.lastIndex = 0;
          while ((match = timePattern.exec(instructionsAfterRoute)) !== null) {
            times.push(...match[0].split(",").map((t) => t.trim()));
          }

          if (times.length > 0) {
            const frequencyWords = [
              "ONCE",
              "TWICE",
              "THREE times",
              "FOUR times",
              "FIVE times",
              "SIX times",
            ];

            const formattedTimes = times.map((time) => {
              const hours = parseInt(time.substring(0, 2));
              const minutes = time.substring(2);
              const period = hours >= 12 ? "pm" : "am";
              const hour12 = hours % 12 || 12;
              return `${hour12}${
                minutes === "00" ? "" : ":" + minutes
              }${period}`;
            });

            const lastTime = formattedTimes.pop();
            const timesList = formattedTimes.length
              ? formattedTimes.join(", ") + " and " + lastTime
              : lastTime;

            const frequencyPhrase =
              times.length <= 6
                ? `${frequencyWords[times.length - 1]} a day at ${timesList}`
                : `${times.length} times a day at ${timesList}`;

            return frequencyPhrase;
          }
        }

        // Process all other standard replacements
        const hourlyRangeRegex =
          /(\d+)(?:\s*-\s*|\s+to\s+)(\d+)\s*(?:hour(?:ly)?|hrly|hr)\b/i;
        const prnRegex = /\bPRN\b/i;
        const uptoRegex = /\bupto\b/gi;
        const numeralRegex = /\b(\d{1,2})\b/g;
        const hrRegex =
          /(\b(?:ONE|TWO|THREE|FOUR|FIVE|SIX|SEVEN|EIGHT|NINE|TEN|ELEVEN|TWELVE|\d{1,2})\b)\s*hr\b/gi;
        const removeRegex =
          /-\d{1,2}(?:,\d{1,2})*(?:am|pm)?(,\d{1,2}(?:am|pm)?)*\b/gi;
        const lunchtimeTeaTimeRegex = /\(12 noon and 6pm\)/gi;

        // Fix the order of these regex replacements - more specific patterns first
        const alternateDaysRegex = /\balternate days\b/gi;
        const alternateMorningsRegex = /\balternate mornings\b/gi;
        const alternateEveningsRegex = /\balternate evenings\b/gi;
        const alternateNightsRegex = /\balternate nights\b/gi;
        // Generic alternate pattern comes last
        const alternateRegex = /\balternate\b/gi;

        const sixhrRegex = /\b6hr\b/gi;
        const twicedayRegex = /\btwice day\b/gi;
        const asrequiredeveryRegex = /\bas required every\b/gi;

        instructionsAfterRoute = instructionsAfterRoute
          .replace(
            hourlyRangeRegex,
            (match, p1, p2) => `every ${p1} to ${p2} hours`
          )
          // Add this to your formatInstructions function
          .replace(
            /(\d+)\s*x\s*week-\s*([a-z]+),([a-z]+),([a-z]+)/i,
            (match, num, day1, day2, day3) =>
              `${convertNumberToWord(
                parseInt(num)
              )} times a week on ${capitalizeDayName(
                day1
              )}, ${capitalizeDayName(day2)} and ${capitalizeDayName(day3)}`
          )
          .replace(removeRegex, "")
          .replace(prnRegex, "")
          .replace(uptoRegex, "up to")
          .replace(lunchtimeTeaTimeRegex, "at lunchtime and teatime")
          .replace("(12,6pm,10pm", " (12pm, 6pm and 10pm)")
          .replace(
            "three times a day(8am,12pm,5pm",
            "three times a day (8am, 12pm and 5pm)"
          )
          .replace("(8am,12pm,6pm)", "(8am, 12pm and 6pm)")
          .replace("(8am,2pm,8pm)", "(8am, 2pm and 8pm)")
          .replace("once a day at 12 noon", "once a day at 12pm (midday)")
          .replace("twice a day(8am and 6pm)", "twice a day (8am and 6pm)")
          .replace(numeralRegex, (match, numeral) => {
            const number = parseInt(numeral, 10);
            return number >= 1 && number <= 12
              ? convertNumberToWord(number)
              : numeral;
          })
          .replace(hrRegex, (match, precedingWord) => {
            const hourWord = precedingWord === "ONE" ? "hour" : "hours";
            return `${precedingWord} ${hourWord}`;
          })
          // Order is important here - do specific patterns first
          .replace(alternateDaysRegex, "every other day")
          .replace(alternateMorningsRegex, "every other morning")
          .replace(alternateEveningsRegex, "every other evening")
          .replace(alternateNightsRegex, "every other night")
          // Generic alternate pattern comes last
          .replace(alternateRegex, "every other")
          .replace(sixhrRegex, "SIX hours")
          .replace(asrequiredeveryRegex, "as required up to every")
          .replace(twicedayRegex, "twice a day")
          // Handle specific day patterns with proper capitalization
          .replace(/\b(mon|tues|wed|thurs|fri|frid|sat|sun)\b/gi, (match) =>
            capitalizeDayName(match)
          )
          .replace(/three times day/i, "three times a day")
          .replace(/once week/i, "once a week")
          // Handle "twice a week" patterns
          .replace(
            /twice a week \((\w+)\+(\w+)\) \d{4}/i,
            (_, day1, day2) =>
              `twice a week on ${capitalizeDayName(
                day1
              )} and ${capitalizeDayName(day2)}`
          )
          // Handle "days of week" patterns
          .replace(
            /days of week am \(omit (\w+)\)/i,
            (_, day) =>
              `days of the Week (every day except ${capitalizeDayName(day)})`
          )
          // Handle days in parentheses with times
          .replace(
            /\((\w+)\)\s*\d{1,2}(?::\d{2})?(?:am|pm)/i,
            (match, day) =>
              `(${capitalizeDayName(day)}) ${match.split(")")[1].trim()}`
          )
          .replace(/\b(mon|monday)\b/gi, "Monday")
          .replace(/\b(tue(s)?|tuesday)\b/gi, "Tuesday")
          .replace(/\b(wed|wednesday)\b/gi, "Wednesday")
          .replace(/\b(thu(rs)?|thursday)\b/gi, "Thursday")
          .replace(/\b(fri(d)?|friday)\b/gi, "Friday")
          .replace(/\b(sat|saturday)\b/gi, "Saturday")
          .replace(/\b(sun|sunday)\b/gi, "Sunday")
          .replace(/once only one/i, "to be taken as a single dose ONCE only")
          .replace("as directed (no specific times", "as directed")
          .trim();

        // Final cleanup for specific time patterns that might remain
        instructionsAfterRoute = instructionsAfterRoute
          .replace(
            /\bat (\d{1,2})(?:am|pm) every other evening\b/i,
            "every other evening"
          )
          .replace(/\bevery other evenings\b/i, "every other evening");

        return instructionsAfterRoute;
      }
      function convertNumberToWord(number) {
        const words = [
          "",
          "ONE",
          "TWO",
          "THREE",
          "FOUR",
          "FIVE",
          "SIX",
          "SEVEN",
          "EIGHT",
          "NINE",
          "TEN",
          "ELEVEN",
          "TWELVE",
        ];
        return words[number];
      }
      function getEyeDropDose(medication, startTime, endTime) {
        const eyeRegex = /\b(BOTH EYES|EYES BOTH|LEFT EYE|RIGHT EYE)\b/i;
        const dropRegex = /(\d+(?:\.\d+)?)\s*(drop|drops)/i;

        const eyeMatch = eyeRegex.exec(medication.instructions);
        const dropMatch = dropRegex.exec(medication.instructions);

        if (
          eyeMatch &&
          dropMatch &&
          (checkTimeRange(medication.instructions, startTime, endTime) ||
            (startTime === "" && endTime === ""))
        ) {
          const drops = parseFloat(dropMatch[1]);
          const route = eyeMatch[0].toUpperCase();
          return `&check; ${formatDropQuantity(drops)} ${route}`;
        }
        return "";
      }
      const supplementSizes = {
        "Nutilis Complete Creme Level 3": 125,
        "Calogen Extra Shots": 40,
        "Nutilis Fruit Level 4": 150,
        "Fresubin Thickened Level 2": 200,
        "Vital 1.5 kcal": 200,
        "Fortisip Compact": 125,
        "Fortisip Plant Based": 200,
        "Forticreme Dessert": 125,
        "Fortijuice Sip Feed": 200,
        "Peptamen Vanilla Liquid": 200,
        Nutricreme: 125,
        "Nutilis Complete Creme": 125,
      };
      function getDoseQuantity(
        medication,
        startTime,
        endTime,
        convertedMedications,
        convertToNumerals = false
      ) {
        const liquidMedication = convertedMedications.find(
          (med) => med.name === medication.name
        );

        const foodSupplementRegex =
          /\b(Fortisip|Vital 1.5|Fortijuice|Ensure|Calogen|Forticreme|Nutilis|Fresubin Thickened|Peptamen Vanilla|Nutricreme)\b/i;

        const volumeRegex = /\b(\d+)\s*(ml|g)\b/i;
        const doseRangeRegex = /\b(\d+)\s*-\s*(\d+)\s*(ml|g)\b/i;

        if (foodSupplementRegex.test(medication.dosage)) {
          const volumeMatch = volumeRegex.exec(medication.dosage);
          const doseMatch = volumeRegex.exec(medication.instructions);
          const doseRangeMatch = doseRangeRegex.exec(medication.instructions);

          const supplementName = Object.keys(supplementSizes).find((name) => {
            // Normalize both strings: remove parentheses, extra spaces, make lowercase
            const normalizedDosage = medication.dosage
              .toLowerCase()
              .replace(/\s*\([^)]*\)\s*/g, " ") // Remove parentheses and their contents
              .replace(/\s+/g, " ") // Replace multiple spaces with a single space
              .trim();

            const normalizedName = name.toLowerCase();

            // Check if the normalized name is included in the normalized dosage
            return normalizedDosage.includes(normalizedName);
          });
          const knownSize = supplementName
            ? supplementSizes[supplementName]
            : null;

          if (knownSize) {
            let numCartons;

            if (doseRangeMatch) {
              const minDoseVolume = parseFloat(doseRangeMatch[1]);
              const maxDoseVolume = parseFloat(doseRangeMatch[2]);
              const minNumCartons = Math.ceil(minDoseVolume / knownSize);
              const maxNumCartons = Math.ceil(maxDoseVolume / knownSize);

              if (
                checkTimeRange(medication.instructions, startTime, endTime) ||
                (startTime === "" && endTime === "")
              ) {
                const minCartonWord =
                  minNumCartons === 1 ? "carton" : "cartons";
                const maxCartonWord =
                  maxNumCartons === 1 ? "carton" : "cartons";
                return `&check; ${formatQuantity(
                  minNumCartons,
                  "",
                  false
                )} to ${formatQuantity(
                  maxNumCartons,
                  "",
                  false
                )} ${maxCartonWord}`;
              }
            } else if (doseMatch) {
              const doseVolume = parseFloat(doseMatch[1]);
              numCartons = Math.ceil(doseVolume / knownSize);

              if (
                checkTimeRange(medication.instructions, startTime, endTime) ||
                (startTime === "" && endTime === "")
              ) {
                const cartonWord = numCartons === 1 ? "carton" : "cartons";
                return `&check; ${formatQuantity(
                  numCartons,
                  "",
                  false
                )} ${cartonWord}`;
              }
            } else if (volumeMatch) {
              const volume = parseFloat(volumeMatch[1]);
              numCartons = Math.ceil(volume / knownSize);

              if (
                checkTimeRange(medication.instructions, startTime, endTime) ||
                (startTime === "" && endTime === "")
              ) {
                const cartonWord = numCartons === 1 ? "carton" : "cartons";
                return `&check; ${formatQuantity(
                  numCartons,
                  "",
                  false
                )} ${cartonWord}`;
              }
            }
          }
        }

        if (
          medication.name.toLowerCase().includes("citalopram") &&
          medication.dosage.toLowerCase().includes("oral drops")
        ) {
          const strengthMatch = /(\d+)\s*MG\/1\s*Drop/i.exec(medication.dosage);
          const strength = strengthMatch ? parseFloat(strengthMatch[1]) : 2;

          const doseMatch = /(\d+(?:\.\d+)?)\s*mg/i.exec(
            medication.instructions
          );
          if (doseMatch) {
            const doseInMg = parseFloat(doseMatch[1]);
            const dropCount = Math.round(doseInMg / strength);

            if (
              checkTimeRange(medication.instructions, startTime, endTime) ||
              (startTime === "" && endTime === "")
            ) {
              return `&check; ${formatDropQuantity(dropCount)}`;
            }
          }
          return "";
        }

        if (
          medication.name.toLowerCase().includes("colecalciferol") &&
          medication.dosage.toLowerCase().includes("iu/drop")
        ) {
          const strengthMatch = /(\d+)\s*IU\/Drop/i.exec(medication.dosage);
          const strength = strengthMatch ? parseFloat(strengthMatch[1]) : 200;

          const dropRegex = /(\d+(?:\.\d+)?)\s*drops?/i;
          const dropMatch = dropRegex.exec(medication.instructions);

          if (dropMatch) {
            const dropCount = parseFloat(dropMatch[1]);
            if (
              checkTimeRange(medication.instructions, startTime, endTime) ||
              (startTime === "" && endTime === "")
            ) {
              return `&check; ${formatDropQuantity(dropCount)}`;
            }
          } else {
            const doseRegex = /([\d,]+(?:\.\d+)?)\s*iu/i;
            const doseMatch = doseRegex.exec(medication.instructions);
            if (doseMatch) {
              const doseInIU = parseFloat(doseMatch[1].replace(/,/g, ""));
              const dropCount = Math.round(doseInIU / strength);
              if (
                checkTimeRange(medication.instructions, startTime, endTime) ||
                (startTime === "" && endTime === "")
              ) {
                return `&check; ${formatDropQuantity(dropCount)}`;
              }
            }
          }
          return "";
        }

        if (medication.name.toLowerCase().includes("scopoderm tts")) {
          if (
            checkTimeRange(medication.instructions, startTime, endTime) ||
            (startTime === "" && endTime === "")
          ) {
            const minDoseInMg = medication.minDose || 1;
            const maxDoseInMg = medication.maxDose || minDoseInMg;
            const minPatches = Math.round(minDoseInMg);
            const maxPatches = Math.round(maxDoseInMg);

            if (minPatches === maxPatches) {
              return `&check; ${formatQuantity(minPatches, "patch", false)}`;
            } else {
              const minPatchesFormatted = formatQuantity(
                minPatches,
                "patch",
                false
              )
                .replace(" patch", "")
                .replace(" patches", "");
              const maxPatchesFormatted = formatQuantity(
                maxPatches,
                "patch",
                false
              );
              return `&check; ${minPatchesFormatted} to ${maxPatchesFormatted}`;
            }
          }
          return "";
        }

        if (
          medication.form === "solution" ||
          medication.form === "syrup" ||
          medication.form === "suspension" ||
          medication.form === "oral solution" ||
          (medication.form === "liquid" &&
            !medication.dosage.toLowerCase().includes("liquid gel")) ||
          medication.form === "elixir" ||
          medication.form === "linctus" ||
          medication.form === "s/f oral soln." ||
          medication.form === "oral soln." ||
          medication.doseUnit === "ml"
        ) {
          if (
            checkTimeRange(medication.instructions, startTime, endTime) ||
            (startTime === "" && endTime === "")
          ) {
            const explicitMlDoseRangeMatch =
              /(\d+(?:,\d+)?(?:\.\d+)?)\s*-\s*(\d+(?:,\d+)?(?:\.\d+)?)\s*ml/i.exec(
                medication.instructions
              );
            const explicitMlDoseMatch = /(\d+(?:,\d+)?(?:\.\d+)?)\s*ml/i.exec(
              medication.instructions
            );

            if (explicitMlDoseRangeMatch) {
              const minDoseInMl = parseFloat(
                explicitMlDoseRangeMatch[1].replace(/,/g, "")
              );
              const maxDoseInMl = parseFloat(
                explicitMlDoseRangeMatch[2].replace(/,/g, "")
              );
              const formattedMinDose = formatQuantity(minDoseInMl, null, true);
              const formattedMaxDose = formatQuantity(maxDoseInMl, null, true);
              return `&check; ${formattedMinDose} to ${formattedMaxDose} ml`;
            } else if (explicitMlDoseMatch) {
              const explicitDoseInMl = parseFloat(
                explicitMlDoseMatch[1].replace(/,/g, "")
              );
              const formattedDose = formatQuantity(
                explicitDoseInMl,
                null,
                true
              );
              return `&check; ${formattedDose} ml`;
            } else {
              const minDoseInMl = convertDose(
                medication.minDose,
                medication.strength,
                medication.strengthVolume
              );
              const maxDoseInMl = convertDose(
                medication.maxDose || medication.minDose,
                medication.strength,
                medication.strengthVolume
              );

              if (minDoseInMl === maxDoseInMl) {
                const formattedDose = formatQuantity(minDoseInMl, null, true);
                return `&check; ${formattedDose} ml`;
              } else {
                const formattedMinDose = formatQuantity(
                  minDoseInMl,
                  null,
                  true
                );
                const formattedMaxDose = formatQuantity(
                  maxDoseInMl,
                  null,
                  true
                );
                return `&check; ${formattedMinDose} to ${formattedMaxDose} ml`;
              }
            }
          }
          return "";
        }

        const parkinsonsmedications = [
          "levodopa",
          "co careldopa",
          "co-beneldopa",
          "entacapone",
          "opicapone",
          "tolcapone",
          "cabergoline",
          "rotigotine",
          "ropinirole",
          "rasagiline",
          "selegiline",
          "pramipexole",
          "bromocriptine",
          "apomorphine",
          "amantadine",
        ];

        const eyeRegex = /\b(BOTH EYES|EYES BOTH|LEFT EYE|RIGHT EYE)\b/i;
        const earRegex = /\b(EARS-BOTH|EAR-LEFT|EAR-RIGHT)\b/i;
        const sprayRangeRegex = /(\d+)\s*-\s*(\d+)\s*spray/i;
        const singleSprayRegex = /(\d+)\s*spray/i;

        const eyeMatch = eyeRegex.exec(medication.instructions);
        const earMatch = earRegex.exec(medication.instructions);
        const sprayRangeMatch = sprayRangeRegex.exec(medication.instructions);
        const singleSprayMatch = singleSprayRegex.exec(medication.instructions);
        if (
          medication.name.toLowerCase().includes("carbomer") &&
          medication.dosage.toLowerCase().includes("liquid gel") &&
          /\b(BOTH EYES|EYES BOTH|LEFT EYE|RIGHT EYE)\b/i.test(
            medication.instructions
          )
        ) {
          const dropRegex = /(\d+(?:\.\d+)?)\s*(drop|drops)/i;
          const dropMatch = dropRegex.exec(medication.instructions);

          if (
            dropMatch &&
            (checkTimeRange(medication.instructions, startTime, endTime) ||
              (startTime === "" && endTime === ""))
          ) {
            const drops = parseFloat(dropMatch[1]);
            const route = medication.instructions
              .match(/\b(BOTH EYES|EYES BOTH|LEFT EYE|RIGHT EYE)\b/i)[0]
              .toUpperCase();
            return `&check; ${formatDropQuantity(drops)} ${route}`;
          }
          return "";
        }
        let route = "";
        if (eyeMatch) {
          route = eyeMatch[0].toUpperCase();
        } else if (earMatch) {
          // Convert old format to new format
          const earRoute = earMatch[0].toUpperCase();
          if (earRoute === "EAR-LEFT") route = "LEFT EAR";
          else if (earRoute === "EAR-RIGHT") route = "RIGHT EAR";
          else if (earRoute === "EARS-BOTH") route = "BOTH EARS";
          else route = earRoute; // Keep as-is if already in new format
        }
        if (
          medication.form === "spray" &&
          earRegex.test(medication.instructions)
        ) {
          if (
            checkTimeRange(medication.instructions, startTime, endTime) ||
            (startTime === "" && endTime === "")
          ) {
            let sprayText = "";
            if (sprayRangeMatch) {
              const minSprays = parseInt(sprayRangeMatch[1]);
              const maxSprays = parseInt(sprayRangeMatch[2]);
              sprayText = `${formatQuantity(
                minSprays,
                null,
                false
              )} to ${formatQuantity(maxSprays, null, false)} sprays`;
            } else if (singleSprayMatch) {
              const sprays = parseInt(singleSprayMatch[1]);
              sprayText = formatQuantity(sprays, "spray", false);
            } else {
              sprayText = "ONE spray";
            }
            return `&check; ${sprayText} ${route}`;
          }
          return "";
        }
        if (
          route &&
          (checkTimeRange(medication.instructions, startTime, endTime) ||
            (startTime === "" && endTime === ""))
        ) {
          if (
            medication.form === "ointment" ||
            medication.form === "liquid" ||
            medication.form === "liquid gel"
          ) {
            return `&check; Apply (${route})`;
          } else {
            const dropRegex =
              /(\d+(?:\.\d+)?)\s*-\s*(\d+(?:\.\d+)?)\s*(drops?)/i;
            const dropMatch = dropRegex.exec(medication.instructions);
            const minDose = dropMatch
              ? parseFloat(dropMatch[1])
              : medication.minDose;
            const maxDose = dropMatch
              ? parseFloat(dropMatch[2])
              : medication.maxDose;
            const doseUnit = dropMatch ? dropMatch[3].toLowerCase() : null;

            if (minDose && maxDose) {
              const formattedMinDose = formatDropQuantity(minDose);
              const formattedMaxDose = formatDropQuantity(maxDose);
              if (minDose === maxDose) {
                return `&check; ${formattedMinDose} ${route}`;
              } else {
                const cleanedMinDose = removeDropsFromDose(formattedMinDose);
                return `&check; ${cleanedMinDose} to ${formattedMaxDose} ${route}`;
              }
            } else if (minDose) {
              const formattedDose = formatDropQuantity(minDose);
              return `&check; ${formattedDose} ${route}`;
            }
          }
        } else if (
          medication.name.toLowerCase().includes("midazolam") &&
          medication.name.toLowerCase().includes("buccal") &&
          medication.name.toLowerCase().includes("solution")
        ) {
          const doseMatch = /(\d+)\s*mg/i.exec(medication.instructions);
          const dose = doseMatch ? parseFloat(doseMatch[1]) : null;
          const strengthMatch = /(\d+)\s*mg/i.exec(medication.dosage);
          const strength = strengthMatch ? parseFloat(strengthMatch[1]) : null;

          if (dose && strength) {
            const numSyringes = Math.round(dose / strength);
            if (
              checkTimeRange(medication.instructions, startTime, endTime) ||
              (startTime === "" && endTime === "")
            ) {
              return `&check; ${formatQuantity(numSyringes, "syringe", false)}`;
            }
            return "";
          } else {
            if (
              checkTimeRange(medication.instructions, startTime, endTime) ||
              (startTime === "" && endTime === "")
            ) {
              return "&check; ONE syringe";
            }
            return "";
          }
        }
        if (liquidMedication) {
          if (
            checkTimeRange(liquidMedication.instructions, startTime, endTime) ||
            (startTime === "" && endTime === "")
          ) {
            if (
              medication.form === "solution" ||
              medication.form === "syrup" ||
              medication.form === "suspension" ||
              medication.form === "oral solution" ||
              (medication.form === "liquid" &&
                !medication.dosage.toLowerCase().includes("liquid gel")) ||
              medication.form === "elixir" ||
              medication.form === "linctus" ||
              medication.form === "s/f oral soln." ||
              medication.form === "oral soln." ||
              medication.doseUnit === "ml"
            ) {
              const minDoseFormatted = formatQuantity(
                liquidMedication.minDose,
                null,
                true
              );
              const maxDoseFormatted = formatQuantity(
                liquidMedication.maxDose || liquidMedication.minDose,
                null,
                true
              );

              if (
                liquidMedication.minDose !== liquidMedication.maxDose &&
                liquidMedication.maxDose
              ) {
                return `&check; ${minDoseFormatted} to ${maxDoseFormatted} ml`;
              } else {
                return `&check; ${minDoseFormatted} ml`;
              }
            }
          }
          return "";
        }

        if (
          medication.minDose === null &&
          medication.maxDose === null &&
          medication.instructions.toLowerCase().includes("see taper")
        ) {
          if (
            checkTimeRange(medication.instructions, startTime, endTime) ||
            (startTime === "" && endTime === "")
          ) {
            return `&check; See Dosing Information Below`;
          }
          return "";
        }
        if (medication.name.toLowerCase().includes("nasal drops")) {
          const dropRangeRegex =
            /(\d+(?:\.\d+)?)\s*-\s*(\d+(?:\.\d+)?)\s*drop/i;
          const dropRangeMatch = dropRangeRegex.exec(medication.instructions);

          if (dropRangeMatch) {
            const minDose = parseInt(dropRangeMatch[1]);
            const maxDose = parseInt(dropRangeMatch[2]);

            if (
              checkTimeRange(medication.instructions, startTime, endTime) ||
              (startTime === "" && endTime === "")
            ) {
              const formattedMinDose = formatDropQuantity(minDose)
                .replace(/\bdrops?\b/g, "")
                .trim();
              const formattedMaxDose = formatDropQuantity(maxDose);
              return `&check; ${formattedMinDose} to ${formattedMaxDose}`;
            }
            return "";
          }

          const dropCountRegex = /(\d+(?:\.\d+)?)\s*drop/i;
          const dropCountMatch = dropCountRegex.exec(medication.instructions);
          const explicitDropCount = dropCountMatch
            ? parseInt(dropCountMatch[1])
            : null;

          if (explicitDropCount) {
            if (
              checkTimeRange(medication.instructions, startTime, endTime) ||
              (startTime === "" && endTime === "")
            ) {
              const formattedDropCount = formatDropQuantity(explicitDropCount);
              return `&check; ${formattedDropCount}`;
            }
            return "";
          }
        } else if (
          medication.form === "cream" ||
          medication.form === "ointment" ||
          medication.form === "sudocrem" ||
          medication.form === "crm" ||
          medication.form === "scalp apllication" ||
          medication.form === "gel" ||
          medication.form === "lotion"
        ) {
          if (medication.isPrn || medication.isSomeDays) {
            const applicRegex = /(\d+)\s*applic/i;
            const applicMatch = applicRegex.exec(medication.instructions);

            if (applicMatch) {
              return "&check; Apply";
            }
          }

          if (
            checkTimeRange(medication.instructions, startTime, endTime) ||
            (startTime === "" && endTime === "")
          ) {
            if (!medication.isPrn && !medication.isSomeDays) {
              return "&check; Apply";
            }
          }
          return "";
        }
        if (
          medication.form === "tablet" ||
          medication.form === "tab" ||
          medication.form === "capsule" ||
          medication.form === "cap"
        ) {
          const doseRangeRegex = /(\d*\.?\d+)\s*-\s*(\d*\.?\d+)\s*(mg|MG)/i;
          const doseRangeMatch = doseRangeRegex.exec(medication.instructions);

          if (doseRangeMatch && medication.strength) {
            const minDose = parseFloat(doseRangeMatch[1]) / medication.strength;
            const maxDose = parseFloat(doseRangeMatch[2]) / medication.strength;

            if (
              checkTimeRange(medication.instructions, startTime, endTime) ||
              (startTime === "" && endTime === "")
            ) {
              let minDoseText =
                minDose === 0.5
                  ? "HALF a"
                  : minDose === 0.25
                  ? "a QUARTER of a"
                  : formatQuantity(minDose, null, false);

              let maxDoseText = formatQuantity(maxDose, null, false);

              const form =
                medication.form === "tab" ? "tablet" : medication.form;

              // If both doses are whole numbers
              if (Number.isInteger(minDose) && Number.isInteger(maxDose)) {
                return `&check; ${minDoseText} to ${maxDoseText} ${form}s`;
              }
              // If starting with a fraction
              else if (minDose < 1 && maxDose >= 1) {
                const formPlural = maxDose > 1 ? `${form}s` : form;
                return `&check; ${minDoseText} ${form} to ${maxDoseText} whole ${formPlural}`;
              } else {
                const formPlural = maxDose > 1 ? `${form}s` : form;
                return `&check; ${minDoseText} ${form} to ${maxDoseText} ${formPlural}`;
              }
            }
            return "";
          }
        }
        const halfTabRegex = /0\.5\s*(tab|tablet)/i;
        const halfTabMatch = halfTabRegex.exec(medication.instructions);
        if (
          halfTabMatch &&
          (medication.form === "tablet" ||
            medication.form === "tab" ||
            medication.form === "capsule" ||
            medication.form === "cap")
        ) {
          if (
            checkTimeRange(medication.instructions, startTime, endTime) ||
            (startTime === "" && endTime === "")
          ) {
            return `&check; HALF  ${medication.form}`;
          }
          return "";
        }

        const quarterTabRegex = /0\.25\s*(tab|tablet)/i;
        const quarterTabMatch = quarterTabRegex.exec(medication.instructions);
        if (
          quarterTabMatch &&
          (medication.form === "tablet" ||
            medication.form === "tab" ||
            medication.form === "capsule" ||
            medication.form === "cap")
        ) {
          if (
            checkTimeRange(medication.instructions, startTime, endTime) ||
            (startTime === "" && endTime === "")
          ) {
            return `&check; a QUARTER of a ${medication.form}`;
          }
          return "";
        } else if (
          medication.form === "inhaler" ||
          medication.form === "easibreathe" ||
          medication.form === "breath actuated" ||
          medication.form === "device" ||
          medication.name.toLowerCase().includes("inhaler") ||
          medication.name.toLowerCase().includes("easibreathe") ||
          medication.name.toLowerCase().includes("inhalator") ||
          medication.name.toLowerCase().includes("breath actuated") ||
          medication.name.toLowerCase().includes("turbohaler") ||
          medication.name.toLowerCase().includes("formoterol") ||
          medication.name.toLowerCase().includes("accuhaler") ||
          medication.name.toLowerCase().includes("evohaler") ||
          medication.name.toLowerCase().includes("easyhaler") ||
          medication.name.toLowerCase().includes("salmeterol") ||
          medication.name.toLowerCase().includes("Breezhaler")
        ) {
          const doseRegex =
            /(\d+(?:\.\d+)?)\s*-\s*(\d+(?:\.\d+)?)\s*(puffs?|doses?|cap|capsule|cartridge)/i;
          const doseMatch = doseRegex.exec(medication.instructions);
          const minDose = doseMatch ? parseFloat(doseMatch[1]) : null;
          const maxDose = doseMatch ? parseFloat(doseMatch[2]) : null;
          const doseUnit = doseMatch ? doseMatch[3].toLowerCase() : null;

          if (minDose && maxDose && doseUnit) {
            if (
              checkTimeRange(medication.instructions, startTime, endTime) ||
              (startTime === "" && endTime === "")
            ) {
              const formattedMinDose = formatInhalerQuantity(minDose, "");
              const formattedMaxDose = formatInhalerQuantity(maxDose, "");
              let formattedDoseUnit = "";

              // Handle proper pluralization for different unit types
              if (
                doseUnit === "cap" ||
                doseUnit === "capsule" ||
                doseUnit === "cartridge"
              ) {
                // Properly handle pluralization for capsules and cartridges
                formattedDoseUnit = maxDose === 1 ? doseUnit : `${doseUnit}s`;
              } else {
                // Handle standard pluralization for puffs/doses
                formattedDoseUnit =
                  maxDose === 1 ? doseUnit.replace(/s$/, "") : doseUnit;
              }

              return `&check; ${formattedMinDose} to ${formattedMaxDose} ${formattedDoseUnit}`;
            }
            return "";
          } else {
            const doseRegex =
              /(\d+(?:\.\d+)?)\s*-\s*(\d+(?:\.\d+)?)\s*(micrograms?|mcgs?|microg)\b/i;
            const doseMatch = doseRegex.exec(medication.instructions);
            const minDose = doseMatch ? parseFloat(doseMatch[1]) : null;
            const maxDose = doseMatch ? parseFloat(doseMatch[2]) : null;
            const doseUnit = doseMatch ? doseMatch[3].toLowerCase() : null;

            if (minDose && maxDose && doseUnit) {
              const strengthRegex =
                /(\d+(?:\.\d+)?)\s*(micrograms?|mcgs?|microg)\b/i;
              const strengthMatch = strengthRegex.exec(medication.dosage);
              const strength = strengthMatch
                ? parseFloat(strengthMatch[1])
                : null;

              if (strength) {
                const minPuffs = Math.round(minDose / strength);
                const maxPuffs = Math.round(maxDose / strength);

                if (
                  checkTimeRange(medication.instructions, startTime, endTime) ||
                  (startTime === "" && endTime === "")
                ) {
                  const formattedMinPuffs = formatInhalerQuantity(minPuffs, "");
                  const formattedMaxPuffs = formatInhalerQuantity(maxPuffs, "");
                  const formattedDoseUnit = maxPuffs === 1 ? "puff" : "puffs";
                  return `&check; ${formattedMinPuffs} to ${formattedMaxPuffs} ${formattedDoseUnit}`;
                }
                return "";
              }
            } else {
              const doseRegex =
                /(\d+(?:\.\d+)?)\s*(puffs?|doses?|cap|capsule|cartridge)/i;
              const doseMatch = doseRegex.exec(medication.instructions);
              const explicitDose = doseMatch ? parseFloat(doseMatch[1]) : null;
              const explicitDoseUnit = doseMatch
                ? doseMatch[2].toLowerCase()
                : null;

              if (explicitDose && explicitDoseUnit) {
                if (
                  checkTimeRange(medication.instructions, startTime, endTime) ||
                  (startTime === "" && endTime === "")
                ) {
                  // Special handling for cartridges and similar items that need proper pluralization
                  if (
                    explicitDoseUnit === "cartridge" ||
                    explicitDoseUnit === "cap" ||
                    explicitDoseUnit === "capsule"
                  ) {
                    const formattedDose = formatQuantity(
                      explicitDose,
                      null,
                      false
                    );
                    const pluralUnit =
                      explicitDose > 1
                        ? `${explicitDoseUnit}s`
                        : explicitDoseUnit;
                    return `&check; ${formattedDose} ${pluralUnit}`;
                  } else {
                    // Default handling for puffs, doses, etc.
                    const formattedDose = formatInhalerQuantity(
                      explicitDose,
                      explicitDoseUnit
                    );
                    return `&check; ${formattedDose}`;
                  }
                }
                return "";
              } else if (
                medication.form === "puffs" ||
                medication.form === "puff" ||
                medication.doseUnit === "puff" ||
                medication.doseUnit === "puffs"
              ) {
                if (
                  checkTimeRange(medication.instructions, startTime, endTime) ||
                  (startTime === "" && endTime === "")
                ) {
                  const formattedPuffs = formatInhalerQuantity(
                    medication.minDose,
                    medication.minDose === 1 ? "puff" : "puffs"
                  );
                  return `&check; ${formattedPuffs}`;
                }
                return "";
              } else if (medication.minDose && medication.strength) {
                const strengthRegex =
                  /(\d+(?:\.\d+)?)\s*(micrograms?|mcgs?|microg)\b/i;
                const strengthMatch = strengthRegex.exec(medication.dosage);
                const strength = strengthMatch
                  ? parseFloat(strengthMatch[1])
                  : null;

                if (strength) {
                  const numPuffs = Math.round(medication.minDose / strength);
                  if (
                    checkTimeRange(
                      medication.instructions,
                      startTime,
                      endTime
                    ) ||
                    (startTime === "" && endTime === "")
                  ) {
                    const formattedPuffs = formatInhalerQuantity(
                      numPuffs,
                      numPuffs === 1 ? "puff" : "puffs"
                    );
                    return `&check; ${formattedPuffs}`;
                  }
                }
                return "";
              }
              return "";
            }
          }
        } else if (
          medication.form === "spray" ||
          medication.form === "sprays" ||
          medication.instructions.toLowerCase().includes("nostril") ||
          (medication.instructions.toLowerCase().includes("sublingual") &&
            !(
              medication.form === "tablet" ||
              medication.form === "capsule" ||
              medication.form === "tab" ||
              medication.form === "cap"
            )) ||
          medication.instructions.toLowerCase().includes("ears-both") ||
          medication.instructions.toLowerCase().includes("ear-left") ||
          medication.instructions.toLowerCase().includes("ear-right")
        ) {
          const sprayCountRegex = /(\d+(?:\.\d+)?)\s*(?:spray|sprays)/i;
          const sprayCountMatch = sprayCountRegex.exec(medication.instructions);
          const explicitSprayCount = sprayCountMatch
            ? parseFloat(sprayCountMatch[1])
            : null;

          if (explicitSprayCount) {
            if (
              checkTimeRange(medication.instructions, startTime, endTime) ||
              (startTime === "" && endTime === "")
            ) {
              const formattedSprayCount =
                formatSprayQuantity(explicitSprayCount);
              return `&check; ${formattedSprayCount}`;
            }
            return "";
          } else if (medication.minDose && medication.strength) {
            const sprayCount = Math.ceil(
              medication.minDose / medication.strength
            );
            if (
              checkTimeRange(medication.instructions, startTime, endTime) ||
              (startTime === "" && endTime === "")
            ) {
              const formattedSprayCount = formatSprayQuantity(sprayCount);
              return `&check; ${formattedSprayCount}`;
            }
            return "";
          }
          return "";
        } else if (
          medication.form === "nebule" ||
          medication.form === "nebules" ||
          medication.form === "nebs" ||
          medication.form === "amps"
        ) {
          if (medication.minDose && medication.strength) {
            const nebuleCount = Math.ceil(
              medication.minDose / medication.strength
            );
            if (
              checkTimeRange(medication.instructions, startTime, endTime) ||
              (startTime === "" && endTime === "")
            ) {
              const formattedNebuleCount = formatQuantity(
                nebuleCount,
                medication.dosage
              );
              return `&check; ${formattedNebuleCount}`;
            }
            return "";
          } else if (medication.minDose) {
            const doseUnit = getProperDoseUnit(medication);
            if (doseUnit === "ml") {
              if (
                checkTimeRange(medication.instructions, startTime, endTime) ||
                (startTime === "" && endTime === "")
              ) {
                const formattedDose = formatQuantity(
                  medication.minDose,
                  medication.dosage
                );
                return `&check; ${formattedDose} ml`;
              }
              return "";
            } else {
              if (
                checkTimeRange(medication.instructions, startTime, endTime) ||
                (startTime === "" && endTime === "")
              ) {
                const formattedDose = formatQuantity(
                  medication.minDose,
                  medication.dosage
                );
                return `&check; ${formattedDose} ${doseUnit}`;
              }
              return "";
            }
          }
          return "";
        } else if (
          checkTimeRange(medication.instructions, startTime, endTime) ||
          (startTime === "" && endTime === "")
        ) {
          if (
            medication.instructions.toLowerCase().includes("see protocol") ||
            medication.instructions
              .toLowerCase()
              .includes("see dose instructions") ||
            medication.instructions.toLowerCase().includes("see taper")
          ) {
            return `&check; See Dosing Information Below`;
          }
          if (
            medication.name.toLowerCase().includes("carbocisteine") &&
            medication.dosage.toLowerCase().includes("sach")
          ) {
            const strengthMatch = /(\d+)\s*MG/.exec(medication.dosage);
            const strength = strengthMatch ? parseFloat(strengthMatch[1]) : 750;

            const sachetRegex = /(\d+(?:\.\d+)?)\s*(sachet|sach)/i;
            const sachetMatch = sachetRegex.exec(medication.instructions);

            if (sachetMatch) {
              const sachetCount = parseFloat(sachetMatch[1]);
              if (
                checkTimeRange(medication.instructions, startTime, endTime) ||
                (startTime === "" && endTime === "")
              ) {
                return `&check; ${formatQuantity(
                  sachetCount,
                  "sachet",
                  false
                )}`;
              }
            } else {
              const doseInMg = medication.minDose;
              if (doseInMg && strength) {
                const sachetCount = doseInMg / strength;
                if (
                  checkTimeRange(medication.instructions, startTime, endTime) ||
                  (startTime === "" && endTime === "")
                ) {
                  return `&check; ${formatQuantity(
                    sachetCount,
                    "sachet",
                    false
                  )}`;
                }
              }
            }
            return "";
          } else if (
            medication.minDose &&
            medication.maxDose &&
            medication.strength &&
            (medication.form === "sachet" ||
              medication.form === "sach" ||
              medication.dosage.includes("Sachet") ||
              medication.dosage.includes("Oral Powder"))
          ) {
            const minQuantity = medication.minDose / medication.strength;
            const maxQuantity = medication.maxDose / medication.strength;
            const formattedMinQuantity = formatQuantity(
              minQuantity,
              "sachet",
              convertToNumerals
            );
            const formattedMaxQuantity = formatQuantity(
              maxQuantity,
              "sachet",
              convertToNumerals
            );
            if (minQuantity === maxQuantity) {
              return `&check; ${formattedMinQuantity}`;
            } else {
              const minWithoutUnit = formattedMinQuantity.replace(
                /\s*sachet(s?)$/,
                ""
              );
              const maxWithoutUnit = formattedMaxQuantity
                .replace(/\s*sachet(s?)$/, "")
                .replace(/\s*sachet(s?)$/, "");
              const unit = maxQuantity === 1 ? "sachet" : "sachets";
              return `&check; ${minWithoutUnit} to ${maxWithoutUnit} ${unit}`;
            }
          } else if (medication.form === "patch") {
            if (
              medication.minDose &&
              medication.maxDose &&
              medication.strength
            ) {
              // Calculate exact patch quantity (might be a fraction)
              const minPatchQuantity = medication.minDose / medication.strength;
              const maxPatchQuantity = medication.maxDose / medication.strength;

              if (minPatchQuantity === maxPatchQuantity) {
                // Handle single dose case
                if (minPatchQuantity === 0.5) {
                  // Half patch
                  if (
                    checkTimeRange(
                      medication.instructions,
                      startTime,
                      endTime
                    ) ||
                    (startTime === "" && endTime === "")
                  ) {
                    return `&check; HALF a patch`;
                  }
                } else if (minPatchQuantity === 0.25) {
                  // Quarter patch
                  if (
                    checkTimeRange(
                      medication.instructions,
                      startTime,
                      endTime
                    ) ||
                    (startTime === "" && endTime === "")
                  ) {
                    return `&check; a QUARTER of a patch`;
                  }
                } else {
                  // Whole number patches
                  const roundedQuantity = Math.ceil(minPatchQuantity);
                  const formattedQuantity = formatQuantity(
                    roundedQuantity,
                    null,
                    false
                  );
                  if (
                    checkTimeRange(
                      medication.instructions,
                      startTime,
                      endTime
                    ) ||
                    (startTime === "" && endTime === "")
                  ) {
                    const patchPlural =
                      roundedQuantity > 1 ? "patches" : "patch";
                    return `&check; ${formattedQuantity} ${patchPlural}`;
                  }
                }
              } else {
                // Handle dose range case
                const formattedMinQuantity = formatQuantity(
                  Math.ceil(minPatchQuantity),
                  null,
                  false
                );
                const formattedMaxQuantity = formatQuantity(
                  Math.ceil(maxPatchQuantity),
                  null,
                  false
                );
                if (
                  checkTimeRange(medication.instructions, startTime, endTime) ||
                  (startTime === "" && endTime === "")
                ) {
                  const patchPlural =
                    Math.ceil(maxPatchQuantity) > 1 ? "patches" : "patch";
                  return `&check; ${formattedMinQuantity} to ${formattedMaxQuantity} ${patchPlural}`;
                }
              }
            }
            return "";
          } else if (
            medication.form === "inhaler" &&
            medication.doseType === "per dose"
          ) {
            const numDoses = Math.round(
              medication.minDose / medication.strength
            );
            const formattedDoses = formatQuantity(numDoses, medication.dosage);
            const formattedStrength = formatQuantity(
              medication.strength,
              medication.dosage
            );
            return `&check; ${formattedDoses} dose${
              numDoses > 1 ? "s" : ""
            } of ${formattedStrength} ${medication.unit}`;
          } else if (
            medication.minDose &&
            (medication.doseUnit === "units" || medication.doseUnit === "unit")
          ) {
            const formattedDose = formatQuantity(
              medication.minDose,
              null,
              false
            );
            return `&check; ${formattedDose} ${
              medication.minDose === 1 ? "unit" : "units"
            }`;
          }
          if (medication.minDose && medication.maxDose) {
            const convertToNumerals = /\b(mg|ml|l|g|microg)\b/i.test(
              getProperDoseUnit(medication)
            );
            const formattedMinDose = formatQuantity(
              medication.minDose,
              null,
              convertToNumerals
            );
            const formattedMaxDose = formatQuantity(
              medication.maxDose,
              null,
              convertToNumerals
            );

            const doseRangeRegex =
              /(\d+)\s*-\s*(\d+)\s*(tab|tablet|capsule|cap|caplet)/i;
            const doseRangeMatch = doseRangeRegex.exec(medication.instructions);

            if (
              medication.form === "gum" ||
              medication.name.toLowerCase().includes("chewing gum") ||
              medication.form === "lozenge" ||
              medication.name.toLowerCase().includes("lozenge")
            ) {
              const doseInMg = parseFloat(medication.minDose);
              const maxDoseInMg = parseFloat(medication.maxDose);
              const strengthInMg = parseFloat(medication.strength);
              if (!isNaN(strengthInMg) && strengthInMg > 0) {
                const minCount = Math.round(doseInMg / strengthInMg);
                const maxCount = Math.round(maxDoseInMg / strengthInMg);
                if (
                  checkTimeRange(medication.instructions, startTime, endTime) ||
                  (startTime === "" && endTime === "")
                ) {
                  const formUnit =
                    medication.form === "gum" ||
                    medication.name.toLowerCase().includes("chewing gum")
                      ? "piece"
                      : "lozenge";
                  if (minCount === maxCount) {
                    const formattedCount = formatQuantity(
                      minCount,
                      formUnit,
                      false
                    );
                    return `&check; ${formattedCount} ${formUnit}${
                      minCount !== 1 ? "s" : ""
                    }`;
                  } else {
                    const formattedMinCount = formatQuantity(
                      minCount,
                      formUnit,
                      false
                    );
                    const formattedMaxCount = formatQuantity(
                      maxCount,
                      formUnit,
                      false
                    );
                    return `&check; ${formattedMinCount} to ${formattedMaxCount} ${formUnit}s`;
                  }
                }
              }
              return "";
            }
            if (
              doseRangeMatch &&
              (medication.form === "tablet" ||
                medication.form === "capsule" ||
                medication.form === "tab" ||
                medication.form === "cap" ||
                medication.form === "lozenge" ||
                medication.form === "gum")
            ) {
              const minDose = parseInt(doseRangeMatch[1]);
              const maxDose = parseInt(doseRangeMatch[2]);
              const doseUnit = doseRangeMatch[3].toLowerCase();

              const formattedMinDose = formatQuantity(minDose, null, false);
              const formattedMaxDose = formatQuantity(maxDose, null, false);

              const form =
                medication.form === "tab" ? "tablet" : medication.form;

              if (minDose === maxDose) {
                return `&check; ${formattedMinDose} ${form}${
                  minDose === 1 ? "" : "s"
                }`;
              } else {
                return `&check; ${formattedMinDose} to ${formattedMaxDose} ${form}s`;
              }
            }
            if (
              parkinsonsmedications.some((med) =>
                medication.name.toLowerCase().includes(med)
              )
            ) {
              const doseTime = getDoseTime(
                medication.instructions,
                startTime,
                endTime
              );
              if (doseTime) {
                if (medication.minDose === medication.maxDose) {
                  if (
                    medication.form === "solution" ||
                    medication.form === "syrup" ||
                    medication.doseUnit === "ml"
                  ) {
                    return `&check; ${formattedMinDose} ml (${doseTime})`;
                  } else {
                    return `&check; ${formattedMinDose} ${getProperDoseUnit(
                      medication,
                      medication.maxDose
                    )} (${doseTime})`;
                  }
                } else {
                  if (
                    medication.form === "solution" ||
                    medication.form === "syrup" ||
                    medication.doseUnit === "ml"
                  ) {
                    return `&check; ${formattedMinDose} to ${formattedMaxDose} ml (${doseTime})`;
                  } else {
                    return `&check; ${formattedMinDose} to ${formattedMaxDose} ${getProperDoseUnit(
                      medication,
                      medication.maxDose
                    )} (${doseTime})`;
                  }
                }
              }
            }

            if (medication.minDose === medication.maxDose) {
              if (
                medication.form === "solution" ||
                medication.form === "syrup" ||
                medication.doseUnit === "ml"
              ) {
                return `&check; ${formattedMinDose} ml`;
              } else {
                return `&check; ${formattedMinDose} ${getProperDoseUnit(
                  medication,
                  medication.maxDose
                )}`;
              }
            } else {
              if (
                medication.form === "solution" ||
                medication.form === "syrup" ||
                medication.doseUnit === "ml"
              ) {
                return `&check; ${formattedMinDose} to ${formattedMaxDose} ml`;
              } else {
                return `&check; ${formattedMinDose} to ${formattedMaxDose} ${getProperDoseUnit(
                  medication,
                  medication.maxDose
                )}`;
              }
            }
          }
        }

        return "";
      }
      function convertDose(dose, strength, strengthVolume) {
        try {
          if (!dose || !strength || !strengthVolume) {
            throw new Error("Missing parameters for dose conversion");
          }
          return (
            (parseFloat(dose) / parseFloat(strength)) *
            parseFloat(strengthVolume)
          );
        } catch (error) {
          return dose; // Return original dose on error
        }
      }
      function getCombinationInhalerDose(medication, startTime, endTime) {
        const combinationInhalerRegex =
          /\[(Fluticasone\s+\d+\s*mcg\s*\/\s*Salmeterol\s+\d+\s*mcg|Glycopyrronium\/Formoterol\/Budes\.\s+\d+(?:\.\d+)?\s*\/\s*\d+(?:\.\d+)?\s*\/\s*\d+(?:\.\d+)?\s*mcg|Ultibro\s+\d+\/\d+mcg\s+Breezhaler)\s+(?:Inhaler|Device|cap\+device)\]/i;
        if (combinationInhalerRegex.test(medication.dosage)) {
          const doseRegex =
            /(\d+(?:\.\d+)?)\s*-\s*(\d+(?:\.\d+)?)\s*(puffs?|doses?|cap|capsule)/i;
          const doseMatch = doseRegex.exec(medication.instructions);
          const minDose = doseMatch ? parseFloat(doseMatch[1]) : null;
          const maxDose = doseMatch ? parseFloat(doseMatch[2]) : null;
          const doseUnit = doseMatch ? doseMatch[3].toLowerCase() : null;

          if (minDose && maxDose && doseUnit) {
            if (
              checkTimeRange(medication.instructions, startTime, endTime) ||
              (startTime === "" && endTime === "")
            ) {
              const formattedMinDose = formatInhalerQuantity(minDose, "");
              const formattedMaxDose = formatInhalerQuantity(maxDose, "");
              let formattedDoseUnit = "";
              if (doseUnit === "cap" || doseUnit === "capsule") {
                formattedDoseUnit = maxDose === 1 ? "capsule" : "capsules";
              } else {
                formattedDoseUnit =
                  maxDose === 1 ? doseUnit.replace(/s$/, "") : doseUnit;
              }
              return `&check; ${formattedMinDose} to ${formattedMaxDose} ${formattedDoseUnit}`;
            }
          } else {
            const doseRegex = /(\d+(?:\.\d+)?)\s*(puffs?|doses?)/i;
            const doseMatch = doseRegex.exec(medication.instructions);
            const explicitDose = doseMatch ? parseFloat(doseMatch[1]) : null;
            const explicitDoseUnit = doseMatch
              ? doseMatch[2].toLowerCase()
              : null;

            if (explicitDose && explicitDoseUnit) {
              if (
                checkTimeRange(medication.instructions, startTime, endTime) ||
                (startTime === "" && endTime === "")
              ) {
                const formattedDose = formatInhalerQuantity(
                  explicitDose,
                  explicitDoseUnit
                );
                return `&check; ${formattedDose}`;
              }
            }
          }
        }
        return null;
      }
      function formatInhalerDoseQuantity(doseQuantity) {
        if (doseQuantity === "ONE puffs") {
          return "ONE puff";
        }
        return doseQuantity;
      }
      function removeDropsFromDose(dose) {
        return dose.replace(/\bdrops?\b/i, "").trim();
      }
      function getDoseTime(instructions, startTime, endTime) {
        const regexTime =
          /\b(1[0-2]|0?[1-9])(?::([0-5][0-9]))?\s*(am|pm)?\b|(\d{1,2})(?:,|$)|(\d{4})(?:,|$)/gi;

        let match;
        while ((match = regexTime.exec(instructions)) !== null) {
          let hours, minutes;
          if (match[5]) {
            hours = parseInt(match[5].substr(0, 2));
            minutes = parseInt(match[5].substr(2, 2));
          } else if (match[1]) {
            hours = parseInt(match[1]);
            minutes = match[2] ? parseInt(match[2]) : 0;
            let ampm = match[3];
            if (ampm === "pm" && hours !== 12) hours += 12;
            else if (ampm === "am" && hours === 12) hours = 0;
          } else {
            hours = parseInt(match[4]);
            minutes = 0;
            if (hours === 12) hours = 12;
            else if (hours >= 1 && hours <= 11) hours = hours;
          }

          const medicationTime = `${hours.toString().padStart(2, "0")}:${minutes
            .toString()
            .padStart(2, "0")}`;
          if (medicationTime >= startTime && medicationTime <= endTime) {
            return formatTime(medicationTime);
          }
        }

        return null;
      }
      function formatTime(timeString) {
        const [hour, minute] = timeString.split(":");
        const parsedHour = parseInt(hour, 10);
        let formattedHour = parsedHour;
        let ampm = "am";
        if (parsedHour >= 12) {
          ampm = "pm";
          if (parsedHour > 12) {
            formattedHour = parsedHour - 12;
          }
        } else if (parsedHour === 0) {
          formattedHour = 12;
        }
        return `${formattedHour}${ampm}`;
      }
      function formatInhalerQuantity(quantity, unit) {
        switch (quantity) {
          case 1:
            return `ONE ${unit.replace(/s$/, "")}`;
          case 2:
            return `TWO ${unit}`;
          case 3:
            return `THREE ${unit}`;
          case 4:
            return `FOUR ${unit}`;
          case 5:
            return `FIVE ${unit}`;
          case 6:
            return `SIX ${unit}`;
          case 7:
            return `SEVEN ${unit}`;
          case 8:
            return `EIGHT ${unit}`;
          case 9:
            return `NINE ${unit}`;
          default:
            return `${quantity} ${unit}`;
        }
      }
      function formatSprayQuantity(quantity) {
        switch (quantity) {
          case 1:
            return "ONE spray";
          case 2:
            return "TWO sprays";
          case 3:
            return "THREE sprays";
          case 4:
            return "FOUR sprays";
          case 5:
            return "FIVE sprays";
          case 6:
            return "SIX sprays";
          case 7:
            return "SEVEN sprays";
          case 8:
            return "EIGHT sprays";
          case 9:
            return "NINE sprays";
          default:
            return `${quantity} sprays`;
        }
      }
      function formatDropQuantity(quantity) {
        if (quantity === 1) {
          return "ONE drop";
        }
        switch (quantity) {
          case 2:
            return "TWO drops";
          case 3:
            return "THREE drops";
          case 4:
            return "FOUR drops";
          case 5:
            return "FIVE drops";
          default:
            return `${quantity} drops`;
        }
      }

      function formatQuantity(quantity, dosage, convertToNumerals = false) {
        let formUnit = "";

        if (dosage) {
          const formRegex =
            /\b(tablet|capsule|tab|cap|sachet|puff|spray|nebule|lozenge|gum)s?\b/i;
          const formMatch = formRegex.exec(dosage);
          if (formMatch) {
            formUnit = formMatch[0].toLowerCase();
          }
        }

        const volumeOrMassUnit = /\b(ml|mg|mcg|ug|l|unit)\b/i.test(
          dosage || ""
        );

        // Handle patches
        if (Number.isInteger(quantity)) {
          let unitForm = formUnit || dosage;
          if (unitForm === "patch" || unitForm === "patches") {
            switch (quantity) {
              case 1:
                return "ONE patch";
              case 2:
                return "TWO patches";
              case 3:
                return "THREE patches";
              case 4:
                return "FOUR patches";
              case 5:
                return "FIVE patches";
              case 6:
                return "SIX patches";
              case 7:
                return "SEVEN patches";
              case 8:
                return "EIGHT patches";
              case 9:
                return "NINE patches";
              default:
                return `${formatNumber(quantity)} patches`;
            }
          }
        }

        // Handle gum, piece, or lozenge
        if (Number.isInteger(quantity)) {
          let unitForm = formUnit;
          if (
            unitForm === "gum" ||
            unitForm === "piece" ||
            unitForm === "lozenge"
          ) {
            switch (quantity) {
              case 1:
                return "ONE";
              case 2:
                return "TWO";
              case 3:
                return "THREE";
              case 4:
                return "FOUR";
              case 5:
                return "FIVE";
              case 6:
                return "SIX";
              case 7:
                return "SEVEN";
              case 8:
                return "EIGHT";
              case 9:
                return "NINE";
              default:
                return formatNumber(quantity);
            }
          }
        }

        // Handle numerals with units
        if (convertToNumerals && volumeOrMassUnit && dosage) {
          const unit = dosage.match(/\b(ml|mg|mcg|ug|l|unit)\b/i);
          return `${formatNumber(quantity)}${unit ? unit[0] : ""}`;
        }
        // Handle integers with numerals
        else if (convertToNumerals && Number.isInteger(quantity)) {
          return formatNumber(quantity);
        }
        // Handle non-integers with numerals
        else if (convertToNumerals && !Number.isInteger(quantity)) {
          const wholeNumber = Math.floor(quantity);
          const fraction = quantity - wholeNumber;
          if (fraction === 0.5) {
            if (wholeNumber === 0) {
              return "0.5";
            } else {
              return `${formatNumber(wholeNumber)}.5`;
            }
          } else if (fraction === 0.25) {
            if (wholeNumber === 0) {
              return "0.25";
            } else {
              return `${formatNumber(wholeNumber)}.25`;
            }
          } else {
            return formatNumber(quantity);
          }
        }
        // Handle volume/mass units (not nebules)
        else if (volumeOrMassUnit && formUnit !== "nebule" && dosage) {
          const unit = dosage.match(/\b(ml|mg|mcg|ug|l|unit)\b/i);
          return `${formatNumber(quantity)}${unit ? unit[0] : ""}`;
        }
        // Handle integers with form units
        else if (Number.isInteger(quantity)) {
          switch (quantity) {
            case 1:
              return `ONE ${formUnit.replace(/s$/, "")}`;
            case 2:
              return `TWO ${formUnit}`;
            case 3:
              return `THREE ${formUnit}`;
            case 4:
              return `FOUR ${formUnit}`;
            case 5:
              return `FIVE ${formUnit}`;
            case 6:
              return `SIX ${formUnit}`;
            case 7:
              return `SEVEN ${formUnit}`;
            case 8:
              return `EIGHT ${formUnit}`;
            case 9:
              return `NINE ${formUnit}`;
            default:
              return `${formatNumber(quantity)} ${formUnit}`;
          }
        }
        // Handle fractions
        else {
          const wholeNumber = Math.floor(quantity);
          const fraction = quantity - wholeNumber;

          if (fraction === 0.5) {
            if (wholeNumber === 0) {
              return `HALF a ${formUnit.replace(/s$/, "")}`;
            } else {
              // Use formatNumber instead of recursive call
              const wholeFormatted =
                wholeNumber === 1
                  ? "ONE"
                  : wholeNumber === 2
                  ? "TWO"
                  : wholeNumber === 3
                  ? "THREE"
                  : wholeNumber === 4
                  ? "FOUR"
                  : wholeNumber === 5
                  ? "FIVE"
                  : wholeNumber === 6
                  ? "SIX"
                  : wholeNumber === 7
                  ? "SEVEN"
                  : wholeNumber === 8
                  ? "EIGHT"
                  : wholeNumber === 9
                  ? "NINE"
                  : formatNumber(wholeNumber);
              return `${wholeFormatted} and a HALF ${formUnit}`;
            }
          } else if (fraction === 0.25) {
            if (wholeNumber === 0) {
              return `a QUARTER of a ${formUnit.replace(/s$/, "")}`;
            } else {
              // Use formatNumber instead of recursive call
              const wholeFormatted =
                wholeNumber === 1
                  ? "ONE"
                  : wholeNumber === 2
                  ? "TWO"
                  : wholeNumber === 3
                  ? "THREE"
                  : wholeNumber === 4
                  ? "FOUR"
                  : wholeNumber === 5
                  ? "FIVE"
                  : wholeNumber === 6
                  ? "SIX"
                  : wholeNumber === 7
                  ? "SEVEN"
                  : wholeNumber === 8
                  ? "EIGHT"
                  : wholeNumber === 9
                  ? "NINE"
                  : formatNumber(wholeNumber);
              return `${wholeFormatted} and a QUARTER of a ${formUnit}`;
            }
          } else {
            // Direct formatting instead of recursive call
            const wholeFormatted =
              wholeNumber === 1
                ? "ONE"
                : wholeNumber === 2
                ? "TWO"
                : wholeNumber === 3
                ? "THREE"
                : wholeNumber === 4
                ? "FOUR"
                : wholeNumber === 5
                ? "FIVE"
                : wholeNumber === 6
                ? "SIX"
                : wholeNumber === 7
                ? "SEVEN"
                : wholeNumber === 8
                ? "EIGHT"
                : wholeNumber === 9
                ? "NINE"
                : formatNumber(wholeNumber);
            return `${wholeFormatted} ${formUnit}`;
          }
        }
      }
      function formatNumber(number) {
        return number.toString().replace(/\B(?=(\d{3})+(?!\d))/g, ",");
      }
      function getProperDoseUnit(medication, quantity) {
        const doseUnit = medication.form || medication.doseUnit;
        if (
          doseUnit &&
          ["ml", "mg", "mcg", "ug", "l", "unit"].includes(
            doseUnit.toLowerCase()
          )
        ) {
          return doseUnit.toLowerCase();
        } else if (doseUnit === "units") {
          return "units";
        } else if (doseUnit === "micrograms") {
          return "microgram";
        } else if (doseUnit === "lozenge") {
          return quantity > 1 ? "lozenges" : "lozenge";
        } else if (doseUnit === "gum") {
          return quantity > 1 ? "pieces" : "piece";
        } else {
          return `${doseUnit}${quantity > 1 ? "s" : ""}`;
        }
      }
      function convertTo24Hour(time) {
        const [hours, minutes] = time
          .match(/(\d+)(?::(\d+))?\s*(am|pm)?/i)
          .slice(1);
        let hour = parseInt(hours, 10);
        const minute = minutes ? parseInt(minutes, 10) : 0;
        const isPM = /pm/i.test(time) && hour !== 12;
        const isAM = /am/i.test(time) && hour === 12;

        if (isPM) hour += 12;
        if (isAM) hour = 0;

        return `${hour.toString().padStart(2, "0")}:${minute
          .toString()
          .padStart(2, "0")}`;
      }
      function checkTimeRange(instructions, startTime, endTime) {
        const routeRegex =
          /\b(ORAL|INHALATION|EAR-LEFT|EAR-RIGHT|EARS-BOTH|LEFT EAR|RIGHT EAR|BOTH EARS|BOTH EYES|LEFT EYE|RIGHT EYE|SUBLINGUAL|INHALE WITH OXYGEN|INHALE WITH AIR|INTRAMUSCULAR|INTRAVENOUS-SLOW INJECTION|UNLICENSED-NEBULISED|NEBULISED|BUCCAL|RECTAL|TOPICAL|NO ROUTE|NOSTRIL-LEFT|NOSTRIL-BOTH|NOSTRIL_RIGHT|NASAL|INTRANASAL|VAGINAL|VAGINALLY|INJECTION|VIA PEG TUBE|SUBCUTANEOUS|UNLICENSED-SUBCUT INFUSION|NASOGASTRIC|NASOJEJUNAL|UNLICENSED-TUBE|UNLICENSED-NG|NASOJEJUNAL|NG|NJ|TOPICALLY|AEROGENAIR|AEROGENOXY)\b/i;
        const routeMatch = routeRegex.exec(instructions);
        const instructionsAfterRoute = routeMatch
          ? instructions
              .substring(routeMatch.index + routeMatch[0].length)
              .trim()
          : instructions;
        // Special case for five times a day with midnight dose
        if (instructionsAfterRoute.match(/five times a day-8,12,16,22,00/i)) {
          if (startTime === "06:00" && endTime === "10:59") return true; // Morning
          if (startTime === "11:00" && endTime === "13:59") return true; // Lunchtime
          if (startTime === "14:00" && endTime === "16:59") return true; // Mid-Afternoon
          if (startTime === "17:00" && endTime === "19:59") return true; // Teatime
          if (startTime === "20:00" && endTime === "23:59") return true; // Bedtime
        }
        const regexTime =
          /\b(1[0-2]|0?[1-9])(?::([0-5][0-9]))?\s*(am|pm)?\b|(\d{1,2})(?:,|$)|(\d{4})(?:,|$)/gi;
        const regexTwiceADay =
          /twice\s+a\s+day\s*\((\d{1,2}(?::\d{2})?\s*(?:am|pm)?)\s*(?:and|&)\s*(\d{1,2}(?::\d{2})?\s*(?:am|pm)?)\)/i;
        const regexThreeTimesADay =
          /three\s+times\s+a\s+day\s*\((\d{1,2}(?::\d{2})?\s*(?:am|pm)?),\s*(\d{1,2}(?::\d{2})?\s*(?:am|pm)?),\s*(\d{1,2}(?::\d{2})?\s*(?:am|pm)?)\)/i;

        const regexMorning = /\b(?:morning|am)\b/i;
        const regexLunchtime = /\blunchtime\b/i;
        const regexNight = /\bnight\b/i;
        const regexNoon = /\b(once a day at noon)\b/gi;
        const regexEvening = /\bevening\b/i;
        const regexAt = /\bat\s+(\d{1,2})(?::(\d{2}))?\s*(am|pm)?/i;

        if (regexMorning.test(instructionsAfterRoute)) {
          return startTime === "06:00" && endTime === "10:59";
        }
        if (regexLunchtime.test(instructionsAfterRoute)) {
          return startTime === "11:00" && endTime === "13:59";
        }
        if (regexNoon.test(instructionsAfterRoute)) {
          return startTime === "11:00" && endTime === "13:59";
        }
        if (
          regexNight.test(instructionsAfterRoute) ||
          regexEvening.test(instructionsAfterRoute)
        ) {
          return startTime === "20:00" && endTime === "23:59";
        }

        const atMatch = regexAt.exec(instructionsAfterRoute);
        if (atMatch) {
          let hour = parseInt(atMatch[1]);
          const minutes = atMatch[2] ? parseInt(atMatch[2]) : 0;
          const ampm = atMatch[3]?.toLowerCase();

          if (ampm === "pm" && hour !== 12) hour += 12;
          else if (ampm === "am" && hour === 12) hour = 0;

          const medicationTime = `${hour.toString().padStart(2, "0")}:${minutes
            .toString()
            .padStart(2, "0")}`;
          return medicationTime >= startTime && medicationTime <= endTime;
        }

        let match;
        while ((match = regexTime.exec(instructionsAfterRoute)) !== null) {
          let hours, minutes;
          if (match[5]) {
            hours = parseInt(match[5].substr(0, 2));
            minutes = parseInt(match[5].substr(2, 2));
          } else if (match[1]) {
            hours = parseInt(match[1]);
            minutes = match[2] ? parseInt(match[2]) : 0;
            let ampm = match[3];
            if (ampm === "pm" && hours !== 12) hours += 12;
            else if (ampm === "am" && hours === 12) hours = 0;
          } else {
            hours = parseInt(match[4]);
            minutes = 0;
            if (hours === 12) hours = 12;
            else if (hours >= 1 && hours <= 11) hours = hours;
          }

          const medicationTime = `${hours.toString().padStart(2, "0")}:${minutes
            .toString()
            .padStart(2, "0")}`;
          if (medicationTime >= startTime && medicationTime <= endTime)
            return true;
        }

        const twiceADayMatch = regexTwiceADay.exec(instructionsAfterRoute);
        if (twiceADayMatch) {
          const time1 = convertTo24Hour(twiceADayMatch[1]);
          const time2 = convertTo24Hour(twiceADayMatch[2]);
          if (
            (time1 >= startTime && time1 <= endTime) ||
            (time2 >= startTime && time2 <= endTime)
          ) {
            return true;
          }
        }

        const threeTimesADayMatch = regexThreeTimesADay.exec(
          instructionsAfterRoute
        );
        if (threeTimesADayMatch) {
          const time1 = convertTo24Hour(threeTimesADayMatch[1]);
          const time2 = convertTo24Hour(threeTimesADayMatch[2]);
          const time3 = convertTo24Hour(threeTimesADayMatch[3]);
          if (
            (time1 >= startTime && time1 <= endTime) ||
            (time2 >= startTime && time2 <= endTime) ||
            (time3 >= startTime && time3 <= endTime)
          ) {
            return true;
          }
        }

        return false;
      }
      function getFrequencyPhrase(frequencyCode) {
        const frequencyMap = {
          PRNOD: "ONCE daily AS REQUIRED",
          PRNON: "AS REQUIRED at night",
          PRNBD: "TWICE daily AS REQUIRED",
          PRNTDS: "THREE times a day AS REQUIRED",
          PRNQDS: "FOUR times a day AS REQUIRED",
          "5D": "FIVE times a day",
          ALTD: "every <u>OTHER</u> DAY",
          ALTM: "every <u>OTHER</u> MORNING",
          ALTL: "every <u>OTHER</u> LUNCHTIME",
          ALTE: "every <u>OTHER</u> EVENING",
          ALTN: "every <u>OTHER</u> NIGHT",
          PRNN: "as required",
          "2WMF": "TWICE a week on Monday and Friday",
          "2WMT": "TWICE a week on Monday and Thursday",
          "2WTF": "TWICE a week on Tuesday and Friday",
          "2WTS": "TWICE a week on Tuesday and Saturday",
          "2WWS": "TWICE a week on Wednesday and Saturday",
          "3WMWF": "THREE times a week on Monday, Wednesday and Friday",
          X1W: "ONCE a week",
          "28D": "Every 28 days",
          "3M": "Every 3 months",
        };

        return frequencyMap[frequencyCode] || formatFrequency(frequencyCode);
      }

      function formatTaperInstructions(taperInstructions, dosage) {
        const lines = taperInstructions.trim().split("\n");
        let formattedInstructions = "";

        for (let i = 0; i < lines.length; i++) {
          const line = lines[i];
          const parts = line.trim().split(/\s+/);
          if (parts.length < 5) continue;

          const dose = parts[0];
          const frequency = parts[1];
          const days = parts[2];

          // Get start date and time
          const startDateStr = parts[4];
          const startTimeStr = parts.length > 5 ? parts[5] : "00:00";

          // Determine first dose time and date
          const firstDose = determineFirstDose(
            startDateStr,
            startTimeStr,
            frequency
          );

          // Calculate dose in tablets/capsules
          const strength = extractStrength(dosage);
          const isSachet =
            dosage.toLowerCase().includes("sachet") ||
            dosage.toLowerCase().includes("oral powder");

          let formattedDose, dosageForm;
          if (isSachet) {
            const sachetDose = parseFloat(dose) / strength;
            formattedDose = formatQuantity(sachetDose, null, false);
            dosageForm = sachetDose === 1 ? "sachet" : "sachets";
          } else {
            const tabletDose = parseFloat(dose) / strength;
            formattedDose = formatQuantity(tabletDose, null, false);

            if (formattedDose.includes("a QUARTER")) {
              dosageForm = dosage.toLowerCase().includes("capsule")
                ? "capsule"
                : "tablet";
            } else if (formattedDose.includes("HALF")) {
              dosageForm =
                tabletDose > 0.5
                  ? dosage.toLowerCase().includes("capsule")
                    ? "capsules"
                    : "tablets"
                  : dosage.toLowerCase().includes("capsule")
                  ? "capsule"
                  : "tablet";
            } else {
              dosageForm =
                tabletDose === 1
                  ? dosage.toLowerCase().includes("capsule")
                    ? "capsule"
                    : "tablet"
                  : dosage.toLowerCase().includes("capsule")
                  ? "capsules"
                  : "tablets";
            }
          }

          // Here's the key change - use the new formatter
          const frequencyPhrase = formatTimeCodesInFrequency(frequency);

          // Format the beginning instruction differently based on frequency type
          let beginningText;
          if (firstDose.isOD) {
            beginningText = `beginning on ${firstDose.date}`;
          } else {
            beginningText = `beginning at ${firstDose.time} on ${firstDose.date}`;
          }

          if (i === lines.length - 1 && parseInt(days) > 56) {
            formattedInstructions += `Take ${formattedDose} ${dosageForm} ${frequencyPhrase} THEREAFTER ${beginningText}`;
          } else {
            formattedInstructions += `Take ${formattedDose} ${dosageForm} ${frequencyPhrase} for ${days} days ${beginningText}`;
            if (i < lines.length - 1) {
              formattedInstructions += ", then<br>";
            } else if (parseInt(days) <= 56) {
              formattedInstructions += ", then STOP";
            }
          }
        }
        formattedInstructions +=
          "<br><br><strong>This shows the entire prescribed course, please make sure to check the date and take the appropriate dose</strong>";

        return formattedInstructions;
      }
      function formatLiquidTaperInstructions(
        taperInstructions,
        medication,
        convertedMedications
      ) {
        const lines = taperInstructions.trim().split("\n");
        let formattedInstructions = "";

        for (let i = 0; i < lines.length; i++) {
          const line = lines[i];
          const parts = line.trim().split(/\s+/);
          if (parts.length < 5) continue;

          const dose = parts[0];
          const frequency = parts[1];
          const days = parts[2];

          // Get start date and time
          const startDateStr = parts[4];
          const startTimeStr = parts.length > 5 ? parts[5] : "00:00";

          // Determine first dose time and date
          const firstDose = determineFirstDose(
            startDateStr,
            startTimeStr,
            frequency
          );

          // Calculate liquid dose
          const liquidMedication = convertedMedications.find(
            (med) => med.name === medication.name
          );
          let doseInMl = parseFloat(dose);

          if (
            liquidMedication &&
            liquidMedication.strength &&
            liquidMedication.strengthVolume
          ) {
            const strengthPerMl =
              liquidMedication.strength / liquidMedication.strengthVolume;
            doseInMl = doseInMl / strengthPerMl;
          }

          const formattedDoseInMl = formatQuantity(doseInMl, null, true);
          const frequencyPhrase = formatTimeCodesInFrequency(frequency);

          // Format the beginning instruction differently based on frequency type
          let beginningText;
          if (firstDose.isOD) {
            beginningText = `beginning on ${firstDose.date}`;
          } else {
            beginningText = `beginning at ${firstDose.time} on ${firstDose.date}`;
          }

          if (i === lines.length - 1 && parseInt(days) > 56) {
            formattedInstructions += `Take ${formattedDoseInMl} ml ${frequencyPhrase} THEREAFTER ${beginningText}`;
          } else {
            formattedInstructions += `Take ${formattedDoseInMl} ml ${frequencyPhrase} for ${days} days ${beginningText}`;
            if (i < lines.length - 1) {
              formattedInstructions += ", then<br>";
            } else if (parseInt(days) <= 56) {
              formattedInstructions += ", then STOP";
            }
          }
        }
        formattedInstructions +=
          "<br><br><strong>This shows the entire prescribed course, please make sure to check the date and take the appropriate dose</strong>";

        return formattedInstructions;
      }

      function formatCreamTaperInstructions(taperInstructions) {
        const lines = taperInstructions.trim().split("\n");
        let formattedInstructions = "";

        for (let i = 0; i < lines.length; i++) {
          const line = lines[i];
          const parts = line.trim().split(/\s+/);
          if (parts.length < 5) continue;

          const dose = parts[0];
          const frequency = parts[1];
          const days = parts[2];

          // Get start date and time
          const startDateStr = parts[4];
          const startTimeStr = parts.length > 5 ? parts[5] : "00:00";

          // Determine first dose time and date
          const firstDose = determineFirstDose(
            startDateStr,
            startTimeStr,
            frequency
          );

          // Format application instructions
          let formattedDose = "Apply";
          if (dose.toLowerCase().includes("applic")) {
            const applicMatch = /(\d+)\s*applic/i.exec(dose);
            if (applicMatch) {
              const applicCount = parseInt(applicMatch[1]);
              if (applicCount !== 1) {
                formattedDose = `Apply ${applicCount} applications`;
              }
            }
          }

          const frequencyPhrase = formatTimeCodesInFrequency(frequency);

          // Format the beginning instruction differently based on frequency type
          let beginningText;
          if (firstDose.isOD) {
            beginningText = `beginning on ${firstDose.date}`;
          } else {
            beginningText = `beginning at ${firstDose.time} on ${firstDose.date}`;
          }

          if (i === lines.length - 1 && parseInt(days) > 56) {
            formattedInstructions += `${formattedDose} ${frequencyPhrase} THEREAFTER ${beginningText}`;
          } else {
            formattedInstructions += `${formattedDose} ${frequencyPhrase} for ${days} days ${beginningText}`;
            if (i < lines.length - 1) {
              formattedInstructions += ", then<br>";
            } else if (parseInt(days) <= 56) {
              formattedInstructions += ", then STOP";
            }
          }
        }
        formattedInstructions +=
          "<br><br><strong>This shows the entire prescribed course, please make sure to check the date and take the appropriate dose</strong>";

        return formattedInstructions;
      }
      function formatMiscellaneousTaperInstructions(
        taperInstructions,
        medication
      ) {
        const lines = taperInstructions.trim().split("\n");
        let formattedInstructions = "";

        // Determine medication type
        const isNebule =
          medication.form === "nebule" ||
          medication.form === "nebules" ||
          medication.form === "nebs" ||
          medication.dosage.toLowerCase().includes("nebule");

        const isInhaler =
          medication.form === "inhaler" ||
          medication.form === "inhalator" ||
          medication.form === "breath actuated" ||
          medication.form === "device" ||
          medication.dosage.toLowerCase().includes("inhaler") ||
          medication.dosage.toLowerCase().includes("turbohaler") ||
          medication.dosage.toLowerCase().includes("accuhaler") ||
          medication.dosage.toLowerCase().includes("breezhaler") ||
          medication.dosage.toLowerCase().includes("nexthaler");

        const isSpray =
          medication.form === "spray" || medication.form === "sprays";

        const isPatch = medication.form === "patch";

        // Check if it's eye drops, ear drops or nasal preparation
        const isEyeDrops =
          medication.dosage.toLowerCase().includes("eye drops") ||
          medication.instructions.toLowerCase().includes("eye") ||
          medication.instructions.toLowerCase().includes("eyes");

        const isEarDrops =
          medication.dosage.toLowerCase().includes("ear drops") ||
          medication.instructions.toLowerCase().includes("ear") ||
          medication.instructions.toLowerCase().includes("ears");

        const isNasalPreparation =
          medication.dosage.toLowerCase().includes("nasal") ||
          medication.instructions.toLowerCase().includes("nostril") ||
          medication.instructions.toLowerCase().includes("nasal");

        // Check if it's a combination medication (contains a slash in the dosage)
        const isCombinationMedication =
          medication.dosage && medication.dosage.match(/\d+\s*\/\s*\d+/);

        // Extract strength from medication dosage - improved regex to handle "/Dose" format
        const strengthRegex = /(\d+(?:\.\d+)?)\s*(?:MG|MCG|mg|mcg)(?:\/Dose)?/i;
        const strengthMatch = medication.dosage
          ? strengthRegex.exec(medication.dosage)
          : null;
        const medicationStrength = strengthMatch
          ? parseFloat(strengthMatch[1])
          : medication.strength;

        // Process each taper line
        for (let i = 0; i < lines.length; i++) {
          const line = lines[i];
          const parts = line.trim().split(/\s+/);
          if (parts.length < 5) continue;

          // Extract raw information from taper instruction line
          const rawDose = parts[0];
          const doseValue = parseFloat(rawDose);
          const frequency = parts[1];
          const days = parts[2];
          const startDateStr = parts[4];
          const startTimeStr = parts.length > 5 ? parts[5] : "00:00";

          // Calculate formatted dose based on medication type
          let formattedDose;
          let actionVerb = "Use";
          let unitText = "";

          // Handle eye drops, ear drops, and nasal preparations
          if (isEyeDrops || isEarDrops || isNasalPreparation) {
            formattedDose = formatNumeralQuantity(doseValue);
            unitText = doseValue === 1 ? "dose" : "doses";

            // Add the route information if present in instructions
            if (
              isEyeDrops &&
              medication.instructions.match(/BOTH EYES|LEFT EYE|RIGHT EYE/i)
            ) {
              const eyeRoute = medication.instructions.match(
                /BOTH EYES|LEFT EYE|RIGHT EYE/i
              )[0];
              actionVerb = ""; // No action verb for eye drops with route
              unitText += ` in ${eyeRoute}`;
            } else if (
              isEarDrops &&
              medication.instructions.match(
                /BOTH EARS|LEFT EAR|RIGHT EAR|EAR-LEFT|EAR-RIGHT|EARS-BOTH/i
              )
            ) {
              let earRoute = medication.instructions.match(
                /BOTH EARS|LEFT EAR|RIGHT EAR|EAR-LEFT|EAR-RIGHT|EARS-BOTH/i
              )[0];
              // Convert old format to new format
              if (earRoute === "EAR-LEFT") earRoute = "LEFT EAR";
              else if (earRoute === "EAR-RIGHT") earRoute = "RIGHT EAR";
              else if (earRoute === "EARS-BOTH") earRoute = "BOTH EARS";

              actionVerb = ""; // No action verb for ear drops with route
              unitText += ` in ${earRoute}`;
            } else if (
              isNasalPreparation &&
              medication.instructions.match(
                /NOSTRIL-LEFT|NOSTRIL-RIGHT|NOSTRIL-BOTH|NOSTRILS/i
              )
            ) {
              const nasalRoute = medication.instructions.match(
                /NOSTRIL-LEFT|NOSTRIL-RIGHT|NOSTRIL-BOTH|NOSTRILS/i
              )[0];
              actionVerb = ""; // No action verb for nasal preparations with route
              unitText += ` in ${nasalRoute.replace(/-/g, " ")}`;
            } else {
              actionVerb = "Apply";
            }
          }
          // Handle combination medications (like Fostair)
          else if (isCombinationMedication) {
            formattedDose = formatNumeralQuantity(doseValue);
            unitText = doseValue === 1 ? "dose" : "doses";
            actionVerb = ""; // No action verb for combination medications
          } else if (isNebule) {
            // For nebules logic
            if (medicationStrength && doseValue === medicationStrength) {
              formattedDose = "ONE nebule";
            } else if (medicationStrength) {
              const nebuleCount = Math.ceil(doseValue / medicationStrength);
              formattedDose = formatQuantity(nebuleCount, "nebule", false);
            } else {
              formattedDose = `${rawDose} ${medication.strengthUnit || ""}`;
            }
            actionVerb = "Use";
          } else if (isInhaler) {
            // Improved inhaler logic
            const isDoseFormat = medication.dosage
              .toLowerCase()
              .includes("/dose");

            // If it's a "/Dose" format, we need to calculate the number of puffs
            if (isDoseFormat && medicationStrength) {
              const puffCount = Math.ceil(doseValue / medicationStrength);
              formattedDose = formatInhalerQuantity(puffCount, "");
              unitText = puffCount === 1 ? "puff" : "puffs";
            }
            // For combination inhalers
            else if (
              medication.dosage.toLowerCase().includes("/") &&
              (medication.name.toLowerCase().includes("symbicort") ||
                medication.name.toLowerCase().includes("seretide") ||
                medication.name.toLowerCase().includes("fostair"))
            ) {
              const puffCount = Math.ceil(doseValue / medicationStrength);
              formattedDose = formatInhalerQuantity(puffCount, "");
              unitText = puffCount === 1 ? "puff" : "puffs";
            }
            // For regular inhalers with known strength
            else if (medicationStrength) {
              const puffCount = Math.ceil(doseValue / medicationStrength);
              formattedDose = formatInhalerQuantity(puffCount, "");
              unitText = puffCount === 1 ? "puff" : "puffs";
            }
            // Fallback for when we can't determine the puff count
            else {
              formattedDose = `${rawDose} ${medication.strengthUnit || ""}`;
              unitText = "";
            }
            actionVerb = "Inhale";
          } else if (isSpray) {
            // Spray logic
            if (medicationStrength) {
              const sprayCount = Math.ceil(doseValue / medicationStrength);
              formattedDose = formatSprayQuantity(sprayCount);
              unitText = ""; // Already included in formatSprayQuantity
            } else {
              formattedDose = formatSprayQuantity(doseValue);
              unitText = ""; // Already included in formatSprayQuantity
            }
            actionVerb = "Use";
          } else if (isPatch) {
            // Patch logic with improved grammar
            if (medicationStrength) {
              const patchCount = Math.ceil(doseValue / medicationStrength);
              // Don't use the formatQuantity function for patches since we want to handle the unit text separately
              if (patchCount === 1) {
                formattedDose = "ONE";
                unitText = "patch";
              } else if (patchCount === 2) {
                formattedDose = "TWO";
                unitText = "patches";
              } else if (patchCount === 3) {
                formattedDose = "THREE";
                unitText = "patches";
              } else if (patchCount === 4) {
                formattedDose = "FOUR";
                unitText = "patches";
              } else if (patchCount === 5) {
                formattedDose = "FIVE";
                unitText = "patches";
              } else {
                formattedDose = patchCount.toString();
                unitText = "patches";
              }
            } else {
              formattedDose = `${rawDose} ${medication.strengthUnit || ""}`;
              unitText = "";
            }
            actionVerb = "Apply";
          } else {
            // For other miscellaneous types, try to use proper grammar
            if (medicationStrength && medication.form) {
              const unitCount = Math.ceil(doseValue / medicationStrength);

              // Handle common forms with singular/plural
              if (medication.form === "tablet" || medication.form === "tab") {
                formattedDose = formatNumeralQuantity(unitCount);
                unitText = unitCount === 1 ? "tablet" : "tablets";
              } else if (
                medication.form === "capsule" ||
                medication.form === "cap"
              ) {
                formattedDose = formatNumeralQuantity(unitCount);
                unitText = unitCount === 1 ? "capsule" : "capsules";
              } else if (
                medication.form === "sachet" ||
                medication.form === "sach"
              ) {
                formattedDose = formatNumeralQuantity(unitCount);
                unitText = unitCount === 1 ? "sachet" : "sachets";
              } else if (medication.form === "lozenge") {
                formattedDose = formatNumeralQuantity(unitCount);
                unitText = unitCount === 1 ? "lozenge" : "lozenges";
              } else {
                // Use formatQuantity for other forms
                formattedDose = formatQuantity(
                  unitCount,
                  medication.form,
                  false
                );
                unitText = ""; // Already included in formatQuantity
              }
            } else {
              formattedDose = `${rawDose} ${medication.strengthUnit || ""}`;
              unitText = "";
            }
            actionVerb = "Use";
          }

          // Determine first dose time and date
          const firstDose = determineFirstDose(
            startDateStr,
            startTimeStr,
            frequency
          );

          // Format the frequency phrase
          const frequencyPhrase = formatTimeCodesInFrequency(frequency);

          // Format the beginning instruction
          let beginningText;
          if (firstDose.isOD) {
            beginningText = `beginning on ${firstDose.date}`;
          } else {
            beginningText = `beginning at ${firstDose.time} on ${firstDose.date}`;
          }

          // Format the taper step with unit text
          const doseWithUnit = unitText
            ? `${formattedDose} ${unitText}`
            : formattedDose;

          if (i === lines.length - 1 && parseInt(days) > 56) {
            formattedInstructions += `${
              actionVerb ? actionVerb + " " : ""
            }${doseWithUnit} ${frequencyPhrase} THEREAFTER ${beginningText}`;
          } else {
            formattedInstructions += `${
              actionVerb ? actionVerb + " " : ""
            }${doseWithUnit} ${frequencyPhrase} for ${days} days ${beginningText}`;
            if (i < lines.length - 1) {
              formattedInstructions += ", then<br>";
            } else if (parseInt(days) <= 56) {
              formattedInstructions += ", then STOP";
            }
          }
        }

        formattedInstructions +=
          "<br><br><strong>This shows the entire prescribed course, please make sure to check the date and take the appropriate dose</strong>";

        return formattedInstructions;
      }

      // Helper function to format numeral quantities with words
      function formatNumeralQuantity(quantity) {
        if (quantity === 1) return "ONE";
        if (quantity === 2) return "TWO";
        if (quantity === 3) return "THREE";
        if (quantity === 4) return "FOUR";
        if (quantity === 5) return "FIVE";
        if (quantity === 6) return "SIX";
        if (quantity === 7) return "SEVEN";
        if (quantity === 8) return "EIGHT";
        if (quantity === 9) return "NINE";
        if (quantity === 10) return "TEN";
        return quantity.toString();
      }
      function checkTaperTimeRange(taperInstructions, startTime, endTime) {
        // Default return value if no match is found
        let result = { isTaperTimeRange: false, frequency: null };

        if (!taperInstructions) {
          return result;
        }

        // Parse taper instructions
        const lines = taperInstructions.trim().split("\n");

        for (const line of lines) {
          const parts = line.trim().split(/\s+/);
          if (parts.length < 5) continue;

          // Extract frequency code
          const frequencyCode = parts[1];

          // Get administration times for this frequency
          const administrationTimes = getFrequencyTimes(frequencyCode);

          // Check if any administration time falls within the given time range
          for (const adminTime of administrationTimes) {
            if (adminTime.time >= startTime && adminTime.time <= endTime) {
              return { isTaperTimeRange: true, frequency: frequencyCode };
            }
          }
        }

        return result;
      }
      function formatTimeCodesInFrequency(frequency) {
        // Check if the frequency is just a string of numbers or contains commas (indicating time codes)
        if (/^\d+(,\d+)*$/.test(frequency)) {
          // Split the time codes
          const timeCodes = frequency.split(",");

          // Convert each time code to a readable format
          const formattedTimes = timeCodes.map((timeCode) => {
            // Handle HHMM format
            if (timeCode.length === 4) {
              const hour = parseInt(timeCode.substring(0, 2));
              const minutes = timeCode.substring(2);
              const period = hour >= 12 ? "pm" : "am";
              const hour12 = hour % 12 || 12;
              return `${hour12}${
                minutes === "00" ? "" : ":" + minutes
              }${period}`;
            }
            // Handle other formats
            return timeCode;
          });

          // Format the result with appropriate wording
          const lastTime = formattedTimes.pop();
          const timesList = formattedTimes.length
            ? formattedTimes.join(", ") + " and " + lastTime
            : lastTime;

          const frequencyWords = [
            "ONCE",
            "TWICE",
            "THREE times",
            "FOUR times",
            "FIVE times",
            "SIX times",
          ];

          // Return formatted time phrase
          if (timeCodes.length <= 6) {
            return `${
              frequencyWords[timeCodes.length - 1]
            } a day at ${timesList}`;
          } else {
            return `${timeCodes.length} times a day at ${timesList}`;
          }
        }

        // If it's not a time code format, return the original frequency or use existing formatter
        return getFrequencyPhrase(frequency);
      }
      // Get all administration times for a frequency code
      function getFrequencyTimes(frequencyCode) {
        // Standard QDS (four times a day) - 8am, 12pm, 6pm, 10pm
        if (frequencyCode === "QDS") {
          return [
            { time: "08:00", label: "8am" },
            { time: "12:00", label: "12pm" },
            { time: "18:00", label: "6pm" },
            { time: "22:00", label: "10pm" },
          ];
        }

        // Standard TDS (three times a day) - 8am, 2pm, 10pm
        if (frequencyCode === "TDS") {
          return [
            { time: "08:00", label: "8am" },
            { time: "14:00", label: "2pm" },
            { time: "22:00", label: "10pm" },
          ];
        }

        // For TDS with explicit times (e.g., TDS81422)
        const tdsMatch = frequencyCode.match(/^TDS(\d+)$/);
        if (tdsMatch && tdsMatch[1]) {
          const timeStr = tdsMatch[1];
          let times = [];

          // Handle different TDS time formats
          if (timeStr.length === 6) {
            // TDS081422
            times = [
              {
                time: `${timeStr.substring(0, 2)}:00`,
                label: formatTimeLabel(`${timeStr.substring(0, 2)}:00`),
              },
              {
                time: `${timeStr.substring(2, 4)}:00`,
                label: formatTimeLabel(`${timeStr.substring(2, 4)}:00`),
              },
              {
                time: `${timeStr.substring(4, 6)}:00`,
                label: formatTimeLabel(`${timeStr.substring(4, 6)}:00`),
              },
            ];
          } else if (timeStr.length === 5) {
            // TDS81422
            times = [
              {
                time: `0${timeStr.substring(0, 1)}:00`,
                label: formatTimeLabel(`0${timeStr.substring(0, 1)}:00`),
              },
              {
                time: `${timeStr.substring(1, 3)}:00`,
                label: formatTimeLabel(`${timeStr.substring(1, 3)}:00`),
              },
              {
                time: `${timeStr.substring(3, 5)}:00`,
                label: formatTimeLabel(`${timeStr.substring(3, 5)}:00`),
              },
            ];
          }

          if (times.length > 0) return times;
        }

        // Standard BD (twice a day) - 8am, 6pm
        if (frequencyCode === "BD") {
          return [
            { time: "08:00", label: "8am" },
            { time: "18:00", label: "6pm" },
          ];
        }

        // For BD with explicit times (e.g., BD0818)
        const bdMatch = frequencyCode.match(/^BD(\d+)$/);
        if (bdMatch && bdMatch[1]) {
          const timeStr = bdMatch[1];
          let times = [];

          if (timeStr.length === 4) {
            // BD0818
            times = [
              {
                time: `${timeStr.substring(0, 2)}:00`,
                label: formatTimeLabel(`${timeStr.substring(0, 2)}:00`),
              },
              {
                time: `${timeStr.substring(2, 4)}:00`,
                label: formatTimeLabel(`${timeStr.substring(2, 4)}:00`),
              },
            ];
          } else if (timeStr.length === 3) {
            // BD818
            times = [
              {
                time: `0${timeStr.substring(0, 1)}:00`,
                label: formatTimeLabel(`0${timeStr.substring(0, 1)}:00`),
              },
              {
                time: `${timeStr.substring(1, 3)}:00`,
                label: formatTimeLabel(`${timeStr.substring(1, 3)}:00`),
              },
            ];
          }

          if (times.length > 0) return times;
        }

        // For OD with explicit time (e.g., OD18 = 6pm)
        const odMatch = frequencyCode.match(/^OD(\d+)$/);
        if (odMatch && odMatch[1]) {
          const timeStr = odMatch[1];
          const hour = parseInt(timeStr, 10);
          const formattedHour = hour.toString().padStart(2, "0");
          return [
            {
              time: `${formattedHour}:00`,
              label: formatTimeLabel(`${formattedHour}:00`),
            },
          ];
        }

        // Standard single-time frequencies
        const standardTimes = {
          OD: [{ time: "08:00", label: "8am" }],
          OM: [{ time: "08:00", label: "8am" }],
          ON: [{ time: "22:00", label: "10pm" }],
          ALTM: [{ time: "08:00", label: "8am" }],
          ALTN: [{ time: "22:00", label: "10pm" }],
          ALTL: [{ time: "12:00", label: "12pm" }],
          ALTE: [{ time: "18:00", label: "6pm" }],
        };

        return (
          standardTimes[frequencyCode] || [{ time: "08:00", label: "8am" }]
        );
      }

      // Helper function to format time in user-friendly format
      function formatTimeLabel(timeString) {
        const [hourStr] = timeString.split(":");
        const hour = parseInt(hourStr, 10);
        const period = hour >= 12 ? "pm" : "am";
        const hour12 = hour % 12 || 12;
        return `${hour12}${period}`;
      }

      function determineFirstDose(startDateStr, startTimeStr, frequencyCode) {
        try {
          // Parse the start date
          const [day, month, year] = startDateStr.split("/");
          const startDate = new Date(`20${year}-${month}-${day}`);

          // Add time component to startDate
          const [hours, minutes] = startTimeStr.split(":");
          startDate.setHours(parseInt(hours, 10), parseInt(minutes, 10));

          // Get all medication administration times for the frequency
          const doseTimes = getFrequencyTimes(frequencyCode);

          // Convert dose times to Date objects for the start date
          const doseDateTimes = doseTimes.map((doseTime) => {
            const [doseHours, doseMinutes] = doseTime.time.split(":");
            const doseDateTime = new Date(startDate);
            doseDateTime.setHours(
              parseInt(doseHours, 10),
              parseInt(doseMinutes, 10),
              0,
              0
            );
            return {
              time: doseTime.time,
              label: doseTime.label,
              dateTime: doseDateTime,
            };
          });

          // Find the first dose time that falls on or after the start time
          // The key change is here - using >= instead of >
          let firstDose = null;
          for (const doseDateTime of doseDateTimes) {
            if (doseDateTime.dateTime >= startDate) {
              firstDose = doseDateTime;
              break;
            }
          }

          // If no dose time is found for today, use the first dose time tomorrow
          if (!firstDose) {
            const tomorrowDate = new Date(startDate);
            tomorrowDate.setDate(tomorrowDate.getDate() + 1);

            const [doseHours, doseMinutes] = doseTimes[0].time.split(":");
            const tomorrowDoseTime = new Date(tomorrowDate);
            tomorrowDoseTime.setHours(
              parseInt(doseHours, 10),
              parseInt(doseMinutes, 10),
              0,
              0
            );

            firstDose = {
              time: doseTimes[0].time,
              label: doseTimes[0].label,
              dateTime: tomorrowDoseTime,
            };
          }

          // Format the results
          const firstDoseDay = firstDose.dateTime
            .getDate()
            .toString()
            .padStart(2, "0");
          const firstDoseMonth = (firstDose.dateTime.getMonth() + 1)
            .toString()
            .padStart(2, "0");
          const firstDoseYear = firstDose.dateTime
            .getFullYear()
            .toString()
            .substring(2);

          return {
            date: `${firstDoseDay}/${firstDoseMonth}/${firstDoseYear}`,
            time: firstDose.label,
            isOD:
              frequencyCode.startsWith("OD") ||
              frequencyCode === "OM" ||
              frequencyCode === "ON",
          };
        } catch (error) {
          console.warn(
            "Error determining first dose, returning original:",
            error
          );
          return {
            date: startDateStr,
            time: "8am",
            isOD: true,
          };
        }
      }

      function formatDate(date) {
        // If date is already a Date object
        if (date instanceof Date) {
          const day = date.getDate().toString().padStart(2, "0");
          const month = (date.getMonth() + 1).toString().padStart(2, "0");
          const year = date.getFullYear().toString().substring(2);
          return `${day}/${month}/${year}`;
        }
        // If date is a string in format "DD/MM/YY"
        else if (typeof date === "string" && date.includes("/")) {
          return date; // Return as is if it's already in the correct format
        }
        // If date is a string in another format, try to parse it
        else if (typeof date === "string") {
          try {
            const dateObj = new Date(date);
            if (!isNaN(dateObj.getTime())) {
              const day = dateObj.getDate().toString().padStart(2, "0");
              const month = (dateObj.getMonth() + 1)
                .toString()
                .padStart(2, "0");
              const year = dateObj.getFullYear().toString().substring(2);
              return `${day}/${month}/${year}`;
            }
          } catch (e) {
            // If parsing fails, return the original string
            console.warn("Could not parse date:", date);
            return date;
          }
        }

        // Fallback - return whatever was passed in
        return date;
      }

      function extractStrength(dosage) {
        const strengthRegex = /(\d+(?:\.\d+)?)\s*(?:mg|mcg|g|ml)/gi;
        let match;
        let totalStrength = 0;

        while ((match = strengthRegex.exec(dosage)) !== null) {
          totalStrength += parseFloat(match[1]);
        }

        return totalStrength || null;
      }

      function formatFrequency(frequencyCode, returnFullTimeInfo = false) {
        const frequencyRegex = /^([A-Z]{2,3})(\d{1,6})?$/;
        const match = frequencyRegex.exec(frequencyCode);

        if (match) {
          const [_, frequency, times] = match;

          switch (frequency) {
            case "OD":
              return formatODFrequency(times, returnFullTimeInfo);
            case "BD":
              return formatBDFrequency(times, returnFullTimeInfo);
            case "OM":
              return returnFullTimeInfo
                ? formatODFrequency("08", true)
                : "in the MORNING";
            case "ON":
              return returnFullTimeInfo
                ? formatODFrequency("22", true)
                : "at NIGHT";
            case "TDS":
              return formatTDSFrequency(times, returnFullTimeInfo);
            case "QDS":
              return formatQDSFrequency(times, returnFullTimeInfo);
            default:
              return frequencyCode;
          }
        }

        return frequencyCode;
      }

      function formatODFrequency(times, returnFullTimeInfo = false) {
        if (!times) return "";

        const hour = parseInt(times);

        // Define time ranges and their descriptions
        const timeRanges = [
          { start: 6, end: 10, label: "in the MORNING", period: "morning" },
          { start: 11, end: 13, label: "at LUNCHTIME", period: "lunchtime" },
          {
            start: 14,
            end: 16,
            label: "in the AFTERNOON",
            period: "mid-afternoon",
          },
          { start: 17, end: 19, label: "at TEATIME", period: "teatime" },
          { start: 20, end: 23, label: "at NIGHT", period: "night" },
        ];

        // Find matching time range
        const timeRange = timeRanges.find(
          (range) => hour >= range.start && hour <= range.end
        );

        // Store full time information in an object
        const timeInfo = {
          hour: hour,
          period: timeRange?.period || "other",
          formattedTime: formatTime(`${hour.toString().padStart(2, "0")}00`),
        };

        // Return full time information if requested
        if (returnFullTimeInfo) {
          return timeInfo;
        }

        // Otherwise return just the display text
        if (timeRange) {
          return timeRange.label;
        }
        return `at ${timeInfo.formattedTime}`;
      }

      function formatBDFrequency(times, returnFullTimeInfo = false) {
        if (!times) return "TWICE a day";

        let times1, times2;
        if (times.length === 4) {
          times1 = parseInt(times.slice(0, 2));
          times2 = parseInt(times.slice(2, 4));
        } else if (times.length === 3) {
          times1 = parseInt(times.slice(0, 1));
          times2 = parseInt(times.slice(1, 3));
        } else {
          return "TWICE a day";
        }

        // Store full time information
        const timeInfo = {
          firstDose: formatODFrequency(
            times1.toString().padStart(2, "0"),
            true
          ),
          secondDose: formatODFrequency(
            times2.toString().padStart(2, "0"),
            true
          ),
        };

        if (returnFullTimeInfo) {
          return timeInfo;
        }

        // Only show times for asymmetric BD doses before 5pm
        if (times1 === 8 && times2 < 17) {
          return `TWICE a day (at ${timeInfo.firstDose.formattedTime} and ${timeInfo.secondDose.formattedTime})`;
        }

        return "TWICE a day";
      }

      function formatTDSFrequency(times, returnFullTimeInfo = false) {
        if (!times) return "three times a day";

        let times1, times2, times3;
        if (times.length === 6) {
          times1 = parseInt(times.slice(0, 2));
          times2 = parseInt(times.slice(2, 4));
          times3 = parseInt(times.slice(4, 6));
        } else if (times.length === 5) {
          times1 = parseInt(times.slice(0, 1));
          times2 = parseInt(times.slice(1, 3));
          times3 = parseInt(times.slice(3, 5));
        } else {
          return "THREE times a day";
        }

        // Store full time information
        const timeInfo = {
          firstDose: formatODFrequency(
            times1.toString().padStart(2, "0"),
            true
          ),
          secondDose: formatODFrequency(
            times2.toString().padStart(2, "0"),
            true
          ),
          thirdDose: formatODFrequency(
            times3.toString().padStart(2, "0"),
            true
          ),
        };

        if (returnFullTimeInfo) {
          return timeInfo;
        }

        // Always return simple frequency for display
        return "THREE times a day";
      }
      function formatQDSFrequency(times, returnFullTimeInfo = false) {
        // QDS times are fixed at 8am, 12pm, 6pm and 10pm
        const standardQDSTimes = [
          { hour: 8, minute: 0 }, // 8am
          { hour: 12, minute: 0 }, // 12pm
          { hour: 18, minute: 0 }, // 6pm
          { hour: 22, minute: 0 }, // 10pm
        ];

        // Store full time information
        const timeInfo = {
          firstDose: formatODFrequency("08", true), // Morning dose
          secondDose: formatODFrequency("12", true), // Lunchtime dose
          thirdDose: formatODFrequency("18", true), // Teatime dose
          fourthDose: formatODFrequency("22", true), // Night dose
          // Store raw times for potential future use
          rawTimes: standardQDSTimes.map((time) => ({
            hour: time.hour,
            minute: time.minute,
            formattedTime: formatTime(
              `${time.hour.toString().padStart(2, "0")}${time.minute
                .toString()
                .padStart(2, "0")}`
            ),
          })),
        };

        if (returnFullTimeInfo) {
          return timeInfo;
        }

        // Always return the simple frequency for display
        return "FOUR times a day";
      }
      function formatTime(timeString) {
        const hour = parseInt(timeString.slice(0, 2), 10);
        let formattedHour = hour;
        let ampm = "am";

        if (hour >= 12) {
          ampm = "pm";
          if (hour > 12) {
            formattedHour = hour - 12;
          }
        } else if (hour === 0) {
          formattedHour = 12;
        }

        return `${formattedHour}${ampm}`;
      }

      function formatDate(dateString) {
        const [day, month, year] = dateString.split("/");
        return `${day}/${month}/${year}`;
      }
      function extract_additional_info(dischargeLetterText) {
        const trigger_phrases = [
          /Dose Changes:/i,
          /DOSE CHANGES:/i,
          /Medications Started in Hospital Comment:/i,
          /Medications Stopped in Hospital Comment:/i,
          /Take Home Medications Comment:/i,
          /Treatment recommendation \(For GP\):/i,
          /Information for the Community Pharmacy:/i,
          /TTO Completed by Ward Pharmacist/i,
          /Medications Authorised by::/i,
        ];

        const end_patterns = [
          /- Allergies/i,
          /Medications Review by Clinician: Yes/i,
        ];

        let additional_info = "";
        let last_end_index = 0;

        while (true) {
          let earliest_match = null;
          let earliest_index = Infinity;

          for (const pattern of trigger_phrases) {
            const match = pattern.exec(
              dischargeLetterText.slice(last_end_index)
            );
            if (match && match.index < earliest_index) {
              earliest_match = match;
              earliest_index = match.index;
            }
          }

          if (!earliest_match) break;

          const start_index = last_end_index + earliest_index;
          let end_index = dischargeLetterText.length;

          for (const end_pattern of end_patterns) {
            const end_match = end_pattern.exec(
              dischargeLetterText.slice(start_index)
            );
            if (end_match) {
              const potential_end_index = start_index + end_match.index;
              if (potential_end_index < end_index) {
                end_index = potential_end_index;
              }
            }
          }

          additional_info +=
            dischargeLetterText.slice(start_index, end_index).trim() + "\n\n";
          last_end_index = end_index;
        }

        return additional_info.trim() || null;
      }
      function printPrescription() {
        const prescriptionContainer = document.getElementById(
          "prescription-container"
        );
        const reminderChartContainer =
          document.getElementById("chart-container");
        const marChartContainer = document.getElementById(
          "mar-chart-container"
        );
        const originalDisplays = {
          prescription: prescriptionContainer.style.display,
          reminder: reminderChartContainer.style.display,
          mar: marChartContainer.style.display,
        };

        // Hide other containers
        reminderChartContainer.style.display = "none";
        marChartContainer.style.display = "none";

        // Ensure prescription is visible
        prescriptionContainer.style.display = "block";

        window.print();

        // Restore original display properties
        prescriptionContainer.style.display = originalDisplays.prescription;
        reminderChartContainer.style.display = originalDisplays.reminder;
        marChartContainer.style.display = originalDisplays.mar;
      }

      function printReminderChart() {
        const prescriptionContainer = document.getElementById(
          "prescription-container"
        );
        const reminderChartContainer =
          document.getElementById("chart-container");
        const marChartContainer = document.getElementById(
          "mar-chart-container"
        );

        prescriptionContainer.style.display = "none";
        marChartContainer.style.display = "none";
        reminderChartContainer.style.display = "block";

        window.print();

        prescriptionContainer.style.display = "";
        marChartContainer.style.display = "";
        reminderChartContainer.style.display = "";
      }

      function printMARChart() {
        const prescriptionContainer = document.getElementById(
          "prescription-container"
        );
        const reminderChartContainer =
          document.getElementById("chart-container");
        const marChartContainer = document.getElementById(
          "mar-chart-container"
        );

        prescriptionContainer.style.display = "none";
        reminderChartContainer.style.display = "none";
        marChartContainer.style.display = "block";

        window.print();

        prescriptionContainer.style.display = "";
        reminderChartContainer.style.display = "";
        marChartContainer.style.display = "";
      }

      // Function to generate MD5 hash for instructions (matches server-side implementation)
      function generateMD5Hash(text) {
        // We'll use a simple implementation since we can't directly use crypto in all browsers
        // This is a basic MD5 implementation for client-side use
        function md5cycle(x, k) {
          let a = x[0],
            b = x[1],
            c = x[2],
            d = x[3];

          a = ff(a, b, c, d, k[0], 7, -680876936);
          d = ff(d, a, b, c, k[1], 12, -389564586);
          c = ff(c, d, a, b, k[2], 17, 606105819);
          b = ff(b, c, d, a, k[3], 22, -1044525330);
          a = ff(a, b, c, d, k[4], 7, -176418897);
          d = ff(d, a, b, c, k[5], 12, 1200080426);
          c = ff(c, d, a, b, k[6], 17, -1473231341);
          b = ff(b, c, d, a, k[7], 22, -45705983);
          a = ff(a, b, c, d, k[8], 7, 1770035416);
          d = ff(d, a, b, c, k[9], 12, -1958414417);
          c = ff(c, d, a, b, k[10], 17, -42063);
          b = ff(b, c, d, a, k[11], 22, -1990404162);
          a = ff(a, b, c, d, k[12], 7, 1804603682);
          d = ff(d, a, b, c, k[13], 12, -40341101);
          c = ff(c, d, a, b, k[14], 17, -1502002290);
          b = ff(b, c, d, a, k[15], 22, 1236535329);

          a = gg(a, b, c, d, k[1], 5, -165796510);
          d = gg(d, a, b, c, k[6], 9, -1069501632);
          c = gg(c, d, a, b, k[11], 14, 643717713);
          b = gg(b, c, d, a, k[0], 20, -373897302);
          a = gg(a, b, c, d, k[5], 5, -701558691);
          d = gg(d, a, b, c, k[10], 9, 38016083);
          c = gg(c, d, a, b, k[15], 14, -660478335);
          b = gg(b, c, d, a, k[4], 20, -405537848);
          a = gg(a, b, c, d, k[9], 5, 568446438);
          d = gg(d, a, b, c, k[14], 9, -1019803690);
          c = gg(c, d, a, b, k[3], 14, -187363961);
          b = gg(b, c, d, a, k[8], 20, 1163531501);
          a = gg(a, b, c, d, k[13], 5, -1444681467);
          d = gg(d, a, b, c, k[2], 9, -51403784);
          c = gg(c, d, a, b, k[7], 14, 1735328473);
          b = gg(b, c, d, a, k[12], 20, -1926607734);

          a = hh(a, b, c, d, k[5], 4, -378558);
          d = hh(d, a, b, c, k[8], 11, -2022574463);
          c = hh(c, d, a, b, k[11], 16, 1839030562);
          b = hh(b, c, d, a, k[14], 23, -35309556);
          a = hh(a, b, c, d, k[1], 4, -1530992060);
          d = hh(d, a, b, c, k[4], 11, 1272893353);
          c = hh(c, d, a, b, k[7], 16, -155497632);
          b = hh(b, c, d, a, k[10], 23, -1094730640);
          a = hh(a, b, c, d, k[13], 4, 681279174);
          d = hh(d, a, b, c, k[0], 11, -358537222);
          c = hh(c, d, a, b, k[3], 16, -722521979);
          b = hh(b, c, d, a, k[6], 23, 76029189);
          a = hh(a, b, c, d, k[9], 4, -640364487);
          d = hh(d, a, b, c, k[12], 11, -421815835);
          c = hh(c, d, a, b, k[15], 16, 530742520);
          b = hh(b, c, d, a, k[2], 23, -995338651);

          a = ii(a, b, c, d, k[0], 6, -198630844);
          d = ii(d, a, b, c, k[7], 10, 1126891415);
          c = ii(c, d, a, b, k[14], 15, -1416354905);
          b = ii(b, c, d, a, k[5], 21, -57434055);
          a = ii(a, b, c, d, k[12], 6, 1700485571);
          d = ii(d, a, b, c, k[3], 10, -1894986606);
          c = ii(c, d, a, b, k[10], 15, -1051523);
          b = ii(b, c, d, a, k[1], 21, -2054922799);
          a = ii(a, b, c, d, k[8], 6, 1873313359);
          d = ii(d, a, b, c, k[15], 10, -30611744);
          c = ii(c, d, a, b, k[6], 15, -1560198380);
          b = ii(b, c, d, a, k[13], 21, 1309151649);
          a = ii(a, b, c, d, k[4], 6, -145523070);
          d = ii(d, a, b, c, k[11], 10, -1120210379);
          c = ii(c, d, a, b, k[2], 15, 718787259);
          b = ii(b, c, d, a, k[9], 21, -343485551);

          x[0] = add32(a, x[0]);
          x[1] = add32(b, x[1]);
          x[2] = add32(c, x[2]);
          x[3] = add32(d, x[3]);
        }

        function cmn(q, a, b, x, s, t) {
          a = add32(add32(a, q), add32(x, t));
          return add32((a << s) | (a >>> (32 - s)), b);
        }

        function ff(a, b, c, d, x, s, t) {
          return cmn((b & c) | (~b & d), a, b, x, s, t);
        }

        function gg(a, b, c, d, x, s, t) {
          return cmn((b & d) | (c & ~d), a, b, x, s, t);
        }

        function hh(a, b, c, d, x, s, t) {
          return cmn(b ^ c ^ d, a, b, x, s, t);
        }

        function ii(a, b, c, d, x, s, t) {
          return cmn(c ^ (b | ~d), a, b, x, s, t);
        }

        function md51(s) {
          const n = s.length;
          const state = [1732584193, -271733879, -1732584194, 271733878];
          let i;

          for (i = 64; i <= s.length; i += 64) {
            md5cycle(state, md5blk(s.substring(i - 64, i)));
          }

          s = s.substring(i - 64);
          const tail = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];

          for (i = 0; i < s.length; i++) {
            tail[i >> 2] |= s.charCodeAt(i) << (i % 4 << 3);
          }

          tail[i >> 2] |= 0x80 << (i % 4 << 3);

          if (i > 55) {
            md5cycle(state, tail);
            for (i = 0; i < 16; i++) tail[i] = 0;
          }

          tail[14] = n * 8;
          md5cycle(state, tail);
          return state;
        }

        function md5blk(s) {
          const md5blks = [];
          for (let i = 0; i < 64; i += 4) {
            md5blks[i >> 2] =
              s.charCodeAt(i) +
              (s.charCodeAt(i + 1) << 8) +
              (s.charCodeAt(i + 2) << 16) +
              (s.charCodeAt(i + 3) << 24);
          }
          return md5blks;
        }

        function add32(a, b) {
          return (a + b) & 0xffffffff;
        }

        function hex(x) {
          let result = "";
          for (let i = 0; i < 4; i++) {
            const n = (x >>> (i * 8)) & 0xff;
            result += ("0" + n.toString(16)).slice(-2);
          }
          return result;
        }

        // Main function to calculate MD5
        const result = md51(text);
        return (
          hex(result[0]) + hex(result[1]) + hex(result[2]) + hex(result[3])
        );
      }

      function generateQRCodes() {
        // Check if MAR chart has been generated
        if (
          !window.medications ||
          window.medications.length === 0 ||
          !window.convertedMedications
        ) {
          alert(
            "Please generate a MAR chart first to extract medications. QR codes can only be generated based on MAR chart data."
          );
          return;
        }

        const qrCodeContainer = document.getElementById("qr-code-container");
        qrCodeContainer.innerHTML = "";

        // Store medication data for QR code generation
        window.qrCodeMedications = [];

        window.medications.forEach((medication, index) => {
          const qrCodeItem = document.createElement("div");
          qrCodeItem.className = "qr-code-item";

          // Get formatted dose information directly from the MAR chart
          let formattedDose = "";

          // Use the same function that the MAR chart uses to format the dose
          formattedDose = getDoseQuantity(
            medication,
            "", // No time filtering for QR codes
            "", // No time filtering for QR codes
            window.convertedMedications || [],
            false // Don't convert to numerals
          );

          // Remove the checkmark if present
          formattedDose = formattedDose.replace("&check; ", "");

          // Remove "See Dosing Information Below" if present
          if (formattedDose === "See Dosing Information Below") {
            formattedDose = "";
          }

          // Get patient-friendly instructions
          let patientFriendlyInstructions = "";

          // Format the instructions based on medication type
          if (medication.isTaper && medication.taperInstructions) {
            if (
              medication.form === "cream" ||
              medication.form === "ointment" ||
              medication.form === "scalp application" ||
              medication.form === "gel" ||
              medication.form === "lotion"
            ) {
              patientFriendlyInstructions = formatCreamTaperInstructions(
                medication.taperInstructions
              );
            } else if (
              medication.form === "solution" ||
              medication.form === "syrup" ||
              medication.form === "suspension" ||
              medication.form === "oral solution" ||
              (medication.form === "liquid" &&
                !medication.dosage.toLowerCase().includes("liquid gel")) ||
              medication.form === "elixir" ||
              medication.form === "linctus" ||
              medication.form === "s/f oral soln." ||
              medication.form === "oral soln." ||
              medication.doseUnit === "ml"
            ) {
              patientFriendlyInstructions = formatLiquidTaperInstructions(
                medication.taperInstructions,
                medication,
                window.convertedMedications || []
              );
            } else if (
              medication.form === "tablet" ||
              medication.form === "capsule" ||
              medication.form === "tab" ||
              medication.form === "cap"
            ) {
              patientFriendlyInstructions = formatTaperInstructions(
                medication.taperInstructions,
                medication.dosage
              );
            } else {
              patientFriendlyInstructions =
                formatMiscellaneousTaperInstructions(
                  medication.taperInstructions,
                  medication
                );
            }
          } else {
            // For non-taper medications, use the formatInstructions function
            patientFriendlyInstructions = formatInstructions(
              medication.instructions || ""
            );
          }

          // Combine dose and instructions
          let combinedInstructions = formattedDose
            ? `${formattedDose} ${patientFriendlyInstructions}`
            : patientFriendlyInstructions;

          // Remove "See Dosing Information Below" from the combined instructions
          combinedInstructions =
            removeSeeDosingInformation(combinedInstructions);

          // Automatically clean HTML tags from instructions
          combinedInstructions =
            cleanHtmlFromInstructions(combinedInstructions);

          // Store medication data for QR code generation
          window.qrCodeMedications.push({
            id: index,
            name: medication.name,
            dosage: medication.dosage,
            timing: medication.timing || medication.frequency || "",
            route: medication.route || "",
            strength: medication.strength || "",
            form: medication.form || "",
            formattedDose: formattedDose,
            patientFriendlyInstructions: patientFriendlyInstructions,
            combinedInstructions: combinedInstructions,
            editedInstructions: combinedInstructions, // Initialize with default instructions
          });

          // Create editable medication card
          const medicationCard = document.createElement("div");
          medicationCard.className = "qr-code-edit-card";
          medicationCard.innerHTML = `
            <div class="medication-header">
              <div style="display: flex; justify-content: space-between; align-items: center;">
                <strong>${medication.name}</strong>
                <label class="toggle-switch">
                  <input type="checkbox" id="qr-toggle-${index}" checked>
                  <span class="toggle-slider"></span>
                </label>
              </div>
            </div>
            <div class="medication-instructions">
              <textarea id="qr-instructions-${index}" rows="3" style="width: 100%">${combinedInstructions}</textarea>
            </div>
            <div class="medication-preview" id="qr-preview-${index}">
              <!-- QR code will be inserted here -->
            </div>
          `;

          // Add event listener to update QR code when instructions change
          medicationCard
            .querySelector(`#qr-instructions-${index}`)
            .addEventListener("input", function (e) {
              const newInstructions = e.target.value;
              updateQRCode(index, newInstructions);
            });

          qrCodeContainer.appendChild(medicationCard);

          // Generate initial QR code
          updateQRCode(index, combinedInstructions);
        });

        // HTML tags are now automatically cleaned, so no need for the manual button

        // Show the modal
        const modal = document.getElementById("qr-code-modal");
        modal.style.display = "block";
      }

      // Function to remove "See Dosing Information Below" from instructions
      function removeSeeDosingInformation(instructions) {
        // Remove the phrase if it appears at the beginning of the instructions
        return instructions.replace(/^See Dosing Information Below\s*/i, "");
      }

      function updateQRCode(index, newInstructions) {
        // Clean HTML tags from instructions
        let cleanedInstructions = cleanHtmlFromInstructions(newInstructions);

        // Update the textarea with cleaned instructions if it differs from input
        if (newInstructions !== cleanedInstructions) {
          const textarea = document.getElementById(`qr-instructions-${index}`);
          if (textarea && textarea.value !== cleanedInstructions) {
            textarea.value = cleanedInstructions;
          }
        }

        // Update the stored instructions with clean version
        window.qrCodeMedications[index].editedInstructions =
          cleanedInstructions;

        // Get the medication data
        const medication = window.qrCodeMedications[index];

        // First, generate a unique ID for this instruction using MD5 hash
        const instructionId = generateMD5Hash(cleanedInstructions);

        // Create a URL that points to the instruction page on the server
        const instructionUrl = `/instruction/${instructionId}`;

        // Generate QR code using qrcode-generator library
        const qr = qrcode(0, "L");
        qr.addData(window.location.origin + instructionUrl);
        qr.make();

        const qrImg = qr.createImgTag(4);

        // Update the QR code in the preview
        const previewElement = document.getElementById(`qr-preview-${index}`);
        previewElement.innerHTML = qrImg;

        // Add a small note below the QR code to indicate it links to an instruction page
        previewElement.innerHTML += `<div style="font-size: 10px; margin-top: 5px;">Scan to view and hear instructions</div>`;

        // Send the medication data to the server to create the instruction page
        createServerInstructionPage(
          instructionId,
          medication.name,
          medication.dosage,
          medication.timing || medication.frequency || "",
          medication.route || "",
          cleanedInstructions
        );
      }

      function printQRCodes() {
        // Check if QR codes have been generated
        if (
          !window.qrCodeMedications ||
          window.qrCodeMedications.length === 0
        ) {
          alert("Please generate QR codes first.");
          return;
        }

        // Get selected medications
        const selectedMedications = window.qrCodeMedications.filter(
          (medication, index) => {
            const toggleElement = document.getElementById(`qr-toggle-${index}`);
            return toggleElement && toggleElement.checked;
          }
        );

        // Check if any medications are selected
        if (selectedMedications.length === 0) {
          alert("Please select at least one medication to print.");
          return;
        }

        // Create a print-friendly version of the QR codes
        const printWindow = window.open("", "_blank");

        // Get all the QR code images from the preview
        const qrCodeData = [];

        selectedMedications.forEach((medication, index) => {
          // Find the original QR code in the preview
          const previewElement = document.getElementById(
            `qr-preview-${medication.id}`
          );
          if (previewElement) {
            const qrImg = previewElement.querySelector("img");
            if (qrImg) {
              // Store the QR code image source and medication data
              qrCodeData.push({
                medication: medication,
                imgSrc: qrImg.src,
              });
            }
          }

          // Clean instructions again to ensure no HTML tags
          const cleanedInstructions = cleanHtmlFromInstructions(
            medication.editedInstructions
          );

          // Generate a unique ID for this instruction using MD5 hash
          const instructionId = generateMD5Hash(cleanedInstructions);

          // Send the medication data to the server to create the instruction page
          createServerInstructionPage(
            instructionId,
            medication.name,
            medication.dosage,
            medication.timing || medication.frequency || "",
            medication.route || "",
            cleanedInstructions
          );
        });

        // Write the HTML content to the print window
        printWindow.document.write(`
          <html>
          <head>
            <title>Medication QR Codes</title>
            <style>
              /* A4 print settings */
              @page {
                size: A4;
                margin: 1cm;
              }
              body { 
                font-family: Arial, sans-serif; 
                margin: 0;
                padding: 0;
              }
              h1 {
                text-align: center;
                margin-bottom: 20px;
                font-size: 18px;
              }
              .qr-code-item { 
  border: 1px solid #ddd;
  padding: 5px;
  width: 3in; 
  height: 1in; 
  box-sizing: border-box;
  display: flex;
  align-items: center;
  background-color: white;
}
              .qr-code-img {
                width: 2.5cm;
                height: 2.5cm;
                display: flex;
                justify-content: center;
                align-items: center;
              }
              .qr-code-img img {
                max-width: 100%;
                max-height: 100%;
              }
              .qr-code-info { 
                font-size: 11px; 
                margin-left: 5px;
                text-align: left;
                width: 4.5cm;
                overflow: hidden;
                display: -webkit-box;
                -webkit-line-clamp: 7;
                -webkit-box-orient: vertical;
                max-height: 2.8cm; /* Ensure text stays within the box */
              }
              .qr-note {
                font-size: 9px;
                color: #666;
                margin-top: 3px;
              }
              @media screen {
                body {
                  padding: 20px;
                }
                .qr-code-container {
                  display: flex;
                  flex-wrap: wrap;
                  justify-content: flex-start;
                  gap: 10px;
                  max-width: 21cm; /* A4 width */
                  margin: 0 auto;
                }
                .qr-code-item {
                  margin: 5px;
                }
              }
              @media print {
  @page {
    size: 3in 1in;
    margin: 0;
  }
  body { margin: 0; padding: 0; }
  h1 { display: none; }
  .qr-code-container {
    display: block;
  }
  .qr-code-item {
    width: 3in;
    height: 1in;
    page-break-after: always;
    break-after: page;
    break-inside: avoid;
    margin: 0;
    padding: 0.1in;
    display: flex;
    align-items: center;
    border: none;
  }
  .qr-code-img {
    height: 0.8in;
    width: 0.8in;
    margin-right: 0.2in;
  }
  .qr-code-info {
    flex: 1;
    display: flex;
    flex-direction: column;
    justify-content: center;
  }
}
            </style>
          </head>
          <body>
            <h1>Medication QR Codes</h1>
            <div class="qr-code-container">
        `);

        // Add each selected medication with its QR code
        qrCodeData.forEach((item) => {
          printWindow.document.write(`
            <div class="qr-code-item">
              <div class="qr-code-img">
                <img src="${item.imgSrc}" alt="QR Code">
              </div>
              <div class="qr-code-info">
                <strong>${item.medication.name}</strong>
                <div class="qr-note">Scan for instructions</div>
              </div>
            </div>
          `);
        });

        // Close the HTML document
        printWindow.document.write(`
            </div>
          </body>
          </html>
        `);

        printWindow.document.close();

        // Wait for images to load before printing
        setTimeout(() => {
          printWindow.focus();
          printWindow.print();
        }, 1000);
      }

      // Add event listener for close button
      document
        .getElementById("close-qr-code")
        .addEventListener("click", function () {
          document.getElementById("qr-code-modal").style.display = "none";
        });

      // Close modal when clicking outside of it
      window.addEventListener("click", function (event) {
        const modal = document.getElementById("qr-code-modal");
        if (event.target === modal) {
          modal.style.display = "none";
        }
      });

      // Function to clean HTML tags from instructions
      function cleanHtmlFromInstructions(instructions) {
        let cleaned = instructions;

        // Replace <br> tags with periods
        cleaned = cleaned.replace(/<br\s*\/?>/gi, ". ");

        // Replace <strong> tags
        cleaned = cleaned.replace(/<strong>(.*?)<\/strong>/gi, "$1");

        // Remove any other HTML tags
        cleaned = cleaned.replace(/<[^>]*>/g, "");

        // Clean up multiple periods and spaces
        cleaned = cleaned.replace(/\.{2,}/g, ".");
        cleaned = cleaned.replace(/\.\s+\./g, ".");
        cleaned = cleaned.replace(/\s+/g, " ");

        return cleaned.trim();
      }

      // Function to send medication data to the server to create an instruction page
      function createServerInstructionPage(
        instructionId,
        medicationName,
        dosage,
        timing,
        route,
        instructions
      ) {
        // Use the cleanHtmlFromInstructions function
        const cleanInstructions = cleanHtmlFromInstructions(instructions);

        // Create the data object to send to the server
        const instructionData = {
          instruction_id: instructionId,
          medication_name: medicationName,
          instructions: cleanInstructions,
          dosage: dosage,
          timing: timing,
          route: route,
        };

        // Send the data to the server using fetch API
        fetch("/create_instruction_page", {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
          },
          body: JSON.stringify(instructionData),
        })
          .then((response) => response.json())
          .then((data) => {
            console.log("Instruction page created:", data);
          })
          .catch((error) => {
            console.error("Error creating instruction page:", error);
          });
      }

      // Function to remove HTML tags from all medication instructions in the QR code editor
      function removeHtmlTagsFromInstructions() {
        // Check if QR codes have been generated
        if (
          !window.qrCodeMedications ||
          window.qrCodeMedications.length === 0
        ) {
          alert("Please generate QR codes first.");
          return;
        }

        // Loop through all medications and clean their instructions
        window.qrCodeMedications.forEach((medication, index) => {
          if (medication.editedInstructions) {
            // Clean HTML tags from instructions
            const cleanedInstructions = cleanHtmlFromInstructions(
              medication.editedInstructions
            );

            // Update the stored instructions with clean version
            medication.editedInstructions = cleanedInstructions;

            // Update the textarea with cleaned instructions
            const textarea = document.getElementById(
              `qr-instructions-${index}`
            );
            if (textarea) {
              textarea.value = cleanedInstructions;
            }

            // Update the QR code with cleaned instructions
            updateQRCode(index, cleanedInstructions);
          }
        });

        alert("HTML tags have been removed from all medication instructions.");
      }

      window.addEventListener("resize", handlePageBreaks);
    </script>
  </body>
</html>
